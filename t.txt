HTTPS://WWW.LEXILOGOS.COM/CLAVIER/MAJUSCULES_MINUSCULES.HTM

3x : https://github.com/torvalds/linux/blob/master/Documentation/DMA-API-HOWTO.txt

=========================
DYNAMIC DMA MAPPING GUIDE
=========================

:AUTHOR: DAVID S. MILLER <DAVEM@REDHAT.COM>
:AUTHOR: RICHARD HENDERSON <RTH@CYGNUS.COM>
:AUTHOR: JAKUB JELINEK <JAKUB@REDHAT.COM>

THIS IS A GUIDE TO DEVICE DRIVER WRITERS ON HOW TO USE THE DMA API
WITH EXAMPLE PSEUDO-CODE.  FOR A CONCISE DESCRIPTION OF THE API, SEE
DMA-API.TXT.

CPU AND DMA ADDRESSES
=====================

THERE ARE SEVERAL KINDS OF ADDRESSES INVOLVED IN THE DMA API, AND IT'S
IMPORTANT TO UNDERSTAND THE DIFFERENCES.

THE KERNEL NORMALLY USES VIRTUAL ADDRESSES.  ANY ADDRESS RETURNED BY
KMALLOC(), VMALLOC(), AND SIMILAR INTERFACES IS A VIRTUAL ADDRESS AND CAN
BE STORED IN A ``VOID *``.

THE VIRTUAL MEMORY SYSTEM (TLB, PAGE TABLES, ETC.) TRANSLATES VIRTUAL
ADDRESSES TO CPU PHYSICAL ADDRESSES, WHICH ARE STORED AS "PHYS_ADDR_T" OR
"RESOURCE_SIZE_T".  THE KERNEL MANAGES DEVICE RESOURCES LIKE REGISTERS AS
PHYSICAL ADDRESSES.  THESE ARE THE ADDRESSES IN /PROC/IOMEM.  THE PHYSICAL
ADDRESS IS NOT DIRECTLY USEFUL TO A DRIVER; IT MUST USE IOREMAP() TO MAP
THE SPACE AND PRODUCE A VIRTUAL ADDRESS.

I/O DEVICES USE A THIRD KIND OF ADDRESS: A "BUS ADDRESS".  IF A DEVICE HAS
REGISTERS AT AN MMIO ADDRESS, OR IF IT PERFORMS DMA TO READ OR WRITE SYSTEM
MEMORY, THE ADDRESSES USED BY THE DEVICE ARE BUS ADDRESSES.  IN SOME
SYSTEMS, BUS ADDRESSES ARE IDENTICAL TO CPU PHYSICAL ADDRESSES, BUT IN
GENERAL THEY ARE NOT.  IOMMUS AND HOST BRIDGES CAN PRODUCE ARBITRARY
MAPPINGS BETWEEN PHYSICAL AND BUS ADDRESSES.

FROM A DEVICE'S POINT OF VIEW, DMA USES THE BUS ADDRESS SPACE, BUT IT MAY
BE RESTRICTED TO A SUBSET OF THAT SPACE.  FOR EXAMPLE, EVEN IF A SYSTEM
SUPPORTS 64-BIT ADDRESSES FOR MAIN MEMORY AND PCI BARS, IT MAY USE AN IOMMU
SO DEVICES ONLY NEED TO USE 32-BIT DMA ADDRESSES.

HERE'S A PICTURE AND SOME EXAMPLES::

               CPU                  CPU                  BUS
             VIRTUAL              PHYSICAL             ADDRESS
             ADDRESS              ADDRESS               SPACE
              SPACE                SPACE

            +-------+             +------+             +------+
            |       |             |MMIO  |   OFFSET    |      |
            |       |  VIRTUAL    |SPACE |   APPLIED   |      |
          C +-------+ --------> B +------+ ----------> +------+ A
            |       |  MAPPING    |      |   BY HOST   |      |
  +-----+   |       |             |      |   BRIDGE    |      |   +--------+
  |     |   |       |             +------+             |      |   |        |
  | CPU |   |       |             | RAM  |             |      |   | DEVICE |
  |     |   |       |             |      |             |      |   |        |
  +-----+   +-------+             +------+             +------+   +--------+
            |       |  VIRTUAL    |BUFFER|   MAPPING   |      |
          X +-------+ --------> Y +------+ <---------- +------+ Z
            |       |  MAPPING    | RAM  |   BY IOMMU
            |       |             |      |
            |       |             |      |
            +-------+             +------+

DURING THE ENUMERATION PROCESS, THE KERNEL LEARNS ABOUT I/O DEVICES AND
THEIR MMIO SPACE AND THE HOST BRIDGES THAT CONNECT THEM TO THE SYSTEM.  FOR
EXAMPLE, IF A PCI DEVICE HAS A BAR, THE KERNEL READS THE BUS ADDRESS (A)
FROM THE BAR AND CONVERTS IT TO A CPU PHYSICAL ADDRESS (B).  THE ADDRESS B
IS STORED IN A STRUCT RESOURCE AND USUALLY EXPOSED VIA /PROC/IOMEM.  WHEN A
DRIVER CLAIMS A DEVICE, IT TYPICALLY USES IOREMAP() TO MAP PHYSICAL ADDRESS
B AT A VIRTUAL ADDRESS (C).  IT CAN THEN USE, E.G., IOREAD32(C), TO ACCESS
THE DEVICE REGISTERS AT BUS ADDRESS A.

IF THE DEVICE SUPPORTS DMA, THE DRIVER SETS UP A BUFFER USING KMALLOC() OR
A SIMILAR INTERFACE, WHICH RETURNS A VIRTUAL ADDRESS (X).  THE VIRTUAL
MEMORY SYSTEM MAPS X TO A PHYSICAL ADDRESS (Y) IN SYSTEM RAM.  THE DRIVER
CAN USE VIRTUAL ADDRESS X TO ACCESS THE BUFFER, BUT THE DEVICE ITSELF
CANNOT BECAUSE DMA DOESN'T GO THROUGH THE CPU VIRTUAL MEMORY SYSTEM.

IN SOME SIMPLE SYSTEMS, THE DEVICE CAN DO DMA DIRECTLY TO PHYSICAL ADDRESS
Y.  BUT IN MANY OTHERS, THERE IS IOMMU HARDWARE THAT TRANSLATES DMA
ADDRESSES TO PHYSICAL ADDRESSES, E.G., IT TRANSLATES Z TO Y.  THIS IS PART
OF THE REASON FOR THE DMA API: THE DRIVER CAN GIVE A VIRTUAL ADDRESS X TO
AN INTERFACE LIKE DMA_MAP_SINGLE(), WHICH SETS UP ANY REQUIRED IOMMU
MAPPING AND RETURNS THE DMA ADDRESS Z.  THE DRIVER THEN TELLS THE DEVICE TO
DO DMA TO Z, AND THE IOMMU MAPS IT TO THE BUFFER AT ADDRESS Y IN SYSTEM
RAM.

SO THAT LINUX CAN USE THE DYNAMIC DMA MAPPING, IT NEEDS SOME HELP FROM THE
DRIVERS, NAMELY IT HAS TO TAKE INTO ACCOUNT THAT DMA ADDRESSES SHOULD BE
MAPPED ONLY FOR THE TIME THEY ARE ACTUALLY USED AND UNMAPPED AFTER THE DMA
TRANSFER.

THE FOLLOWING API WILL WORK OF COURSE EVEN ON PLATFORMS WHERE NO SUCH
HARDWARE EXISTS.

NOTE THAT THE DMA API WORKS WITH ANY BUS INDEPENDENT OF THE UNDERLYING
MICROPROCESSOR ARCHITECTURE. YOU SHOULD USE THE DMA API RATHER THAN THE
BUS-SPECIFIC DMA API, I.E., USE THE DMA_MAP_*() INTERFACES RATHER THAN THE
PCI_MAP_*() INTERFACES.

FIRST OF ALL, YOU SHOULD MAKE SURE::

	#INCLUDE <LINUX/DMA-MAPPING.H>

IS IN YOUR DRIVER, WHICH PROVIDES THE DEFINITION OF DMA_ADDR_T.  THIS TYPE
CAN HOLD ANY VALID DMA ADDRESS FOR THE PLATFORM AND SHOULD BE USED
EVERYWHERE YOU HOLD A DMA ADDRESS RETURNED FROM THE DMA MAPPING FUNCTIONS.

WHAT MEMORY IS DMA'ABLE?
========================

THE FIRST PIECE OF INFORMATION YOU MUST KNOW IS WHAT KERNEL MEMORY CAN
BE USED WITH THE DMA MAPPING FACILITIES.  THERE HAS BEEN AN UNWRITTEN
SET OF RULES REGARDING THIS, AND THIS TEXT IS AN ATTEMPT TO FINALLY
WRITE THEM DOWN.

IF YOU ACQUIRED YOUR MEMORY VIA THE PAGE ALLOCATOR
(I.E. __GET_FREE_PAGE*()) OR THE GENERIC MEMORY ALLOCATORS
(I.E. KMALLOC() OR KMEM_CACHE_ALLOC()) THEN YOU MAY DMA TO/FROM
THAT MEMORY USING THE ADDRESSES RETURNED FROM THOSE ROUTINES.

THIS MEANS SPECIFICALLY THAT YOU MAY _NOT_ USE THE MEMORY/ADDRESSES
RETURNED FROM VMALLOC() FOR DMA.  IT IS POSSIBLE TO DMA TO THE
_UNDERLYING_ MEMORY MAPPED INTO A VMALLOC() AREA, BUT THIS REQUIRES
WALKING PAGE TABLES TO GET THE PHYSICAL ADDRESSES, AND THEN
TRANSLATING EACH OF THOSE PAGES BACK TO A KERNEL ADDRESS USING
SOMETHING LIKE __VA().  [ EDIT: UPDATE THIS WHEN WE INTEGRATE
GERD KNORR'S GENERIC CODE WHICH DOES THIS. ]

THIS RULE ALSO MEANS THAT YOU MAY USE NEITHER KERNEL IMAGE ADDRESSES
(ITEMS IN DATA/TEXT/BSS SEGMENTS), NOR MODULE IMAGE ADDRESSES, NOR
STACK ADDRESSES FOR DMA.  THESE COULD ALL BE MAPPED SOMEWHERE ENTIRELY
DIFFERENT THAN THE REST OF PHYSICAL MEMORY.  EVEN IF THOSE CLASSES OF
MEMORY COULD PHYSICALLY WORK WITH DMA, YOU'D NEED TO ENSURE THE I/O
BUFFERS WERE CACHELINE-ALIGNED.  WITHOUT THAT, YOU'D SEE CACHELINE
SHARING PROBLEMS (DATA CORRUPTION) ON CPUS WITH DMA-INCOHERENT CACHES.
(THE CPU COULD WRITE TO ONE WORD, DMA WOULD WRITE TO A DIFFERENT ONE
IN THE SAME CACHE LINE, AND ONE OF THEM COULD BE OVERWRITTEN.)

ALSO, THIS MEANS THAT YOU CANNOT TAKE THE RETURN OF A KMAP()
CALL AND DMA TO/FROM THAT.  THIS IS SIMILAR TO VMALLOC().

WHAT ABOUT BLOCK I/O AND NETWORKING BUFFERS?  THE BLOCK I/O AND
NETWORKING SUBSYSTEMS MAKE SURE THAT THE BUFFERS THEY USE ARE VALID
FOR YOU TO DMA FROM/TO.

DMA ADDRESSING CAPABILITIES
===========================

BY DEFAULT, THE KERNEL ASSUMES THAT YOUR DEVICE CAN ADDRESS 32-BITS OF DMA
ADDRESSING.  FOR A 64-BIT CAPABLE DEVICE, THIS NEEDS TO BE INCREASED, AND FOR
A DEVICE WITH LIMITATIONS, IT NEEDS TO BE DECREASED.

SPECIAL NOTE ABOUT PCI: PCI-X SPECIFICATION REQUIRES PCI-X DEVICES TO SUPPORT
64-BIT ADDRESSING (DAC) FOR ALL TRANSACTIONS.  AND AT LEAST ONE PLATFORM (SGI
SN2) REQUIRES 64-BIT CONSISTENT ALLOCATIONS TO OPERATE CORRECTLY WHEN THE IO
BUS IS IN PCI-X MODE.

FOR CORRECT OPERATION, YOU MUST SET THE DMA MASK TO INFORM THE KERNEL ABOUT
YOUR DEVICES DMA ADDRESSING CAPABILITIES.

THIS IS PERFORMED VIA A CALL TO DMA_SET_MASK_AND_COHERENT()::

	INT DMA_SET_MASK_AND_COHERENT(STRUCT DEVICE *DEV, U64 MASK);

WHICH WILL SET THE MASK FOR BOTH STREAMING AND COHERENT APIS TOGETHER.  IF YOU
HAVE SOME SPECIAL REQUIREMENTS, THEN THE FOLLOWING TWO SEPARATE CALLS CAN BE
USED INSTEAD:

	THE SETUP FOR STREAMING MAPPINGS IS PERFORMED VIA A CALL TO
	DMA_SET_MASK()::

		INT DMA_SET_MASK(STRUCT DEVICE *DEV, U64 MASK);

	THE SETUP FOR CONSISTENT ALLOCATIONS IS PERFORMED VIA A CALL
	TO DMA_SET_COHERENT_MASK()::

		INT DMA_SET_COHERENT_MASK(STRUCT DEVICE *DEV, U64 MASK);

HERE, DEV IS A POINTER TO THE DEVICE STRUCT OF YOUR DEVICE, AND MASK IS A BIT
MASK DESCRIBING WHICH BITS OF AN ADDRESS YOUR DEVICE SUPPORTS.  OFTEN THE
DEVICE STRUCT OF YOUR DEVICE IS EMBEDDED IN THE BUS-SPECIFIC DEVICE STRUCT OF
YOUR DEVICE.  FOR EXAMPLE, &PDEV->DEV IS A POINTER TO THE DEVICE STRUCT OF A
PCI DEVICE (PDEV IS A POINTER TO THE PCI DEVICE STRUCT OF YOUR DEVICE).

THESE CALLS USUALLY RETURN ZERO TO INDICATED YOUR DEVICE CAN PERFORM DMA
PROPERLY ON THE MACHINE GIVEN THE ADDRESS MASK YOU PROVIDED, BUT THEY MIGHT
RETURN AN ERROR IF THE MASK IS TOO SMALL TO BE SUPPORTABLE ON THE GIVEN
SYSTEM.  IF IT RETURNS NON-ZERO, YOUR DEVICE CANNOT PERFORM DMA PROPERLY ON
THIS PLATFORM, AND ATTEMPTING TO DO SO WILL RESULT IN UNDEFINED BEHAVIOR.
YOU MUST NOT USE DMA ON THIS DEVICE UNLESS THE DMA_SET_MASK FAMILY OF
FUNCTIONS HAS RETURNED SUCCESS.

THIS MEANS THAT IN THE FAILURE CASE, YOU HAVE TWO OPTIONS:

1) USE SOME NON-DMA MODE FOR DATA TRANSFER, IF POSSIBLE.
2) IGNORE THIS DEVICE AND DO NOT INITIALIZE IT.

IT IS RECOMMENDED THAT YOUR DRIVER PRINT A KERNEL KERN_WARNING MESSAGE WHEN
SETTING THE DMA MASK FAILS.  IN THIS MANNER, IF A USER OF YOUR DRIVER REPORTS
THAT PERFORMANCE IS BAD OR THAT THE DEVICE IS NOT EVEN DETECTED, YOU CAN ASK
THEM FOR THE KERNEL MESSAGES TO FIND OUT EXACTLY WHY.

THE STANDARD 64-BIT ADDRESSING DEVICE WOULD DO SOMETHING LIKE THIS::

	IF (DMA_SET_MASK_AND_COHERENT(DEV, DMA_BIT_MASK(64))) {
		DEV_WARN(DEV, "MYDEV: NO SUITABLE DMA AVAILABLE\N");
		GOTO IGNORE_THIS_DEVICE;
	}

IF THE DEVICE ONLY SUPPORTS 32-BIT ADDRESSING FOR DESCRIPTORS IN THE
COHERENT ALLOCATIONS, BUT SUPPORTS FULL 64-BITS FOR STREAMING MAPPINGS
IT WOULD LOOK LIKE THIS::

	IF (DMA_SET_MASK(DEV, DMA_BIT_MASK(64))) {
		DEV_WARN(DEV, "MYDEV: NO SUITABLE DMA AVAILABLE\N");
		GOTO IGNORE_THIS_DEVICE;
	}

THE COHERENT MASK WILL ALWAYS BE ABLE TO SET THE SAME OR A SMALLER MASK AS
THE STREAMING MASK. HOWEVER FOR THE RARE CASE THAT A DEVICE DRIVER ONLY
USES CONSISTENT ALLOCATIONS, ONE WOULD HAVE TO CHECK THE RETURN VALUE FROM
DMA_SET_COHERENT_MASK().

FINALLY, IF YOUR DEVICE CAN ONLY DRIVE THE LOW 24-BITS OF
ADDRESS YOU MIGHT DO SOMETHING LIKE::

	IF (DMA_SET_MASK(DEV, DMA_BIT_MASK(24))) {
		DEV_WARN(DEV, "MYDEV: 24-BIT DMA ADDRESSING NOT AVAILABLE\N");
		GOTO IGNORE_THIS_DEVICE;
	}

WHEN DMA_SET_MASK() OR DMA_SET_MASK_AND_COHERENT() IS SUCCESSFUL, AND
RETURNS ZERO, THE KERNEL SAVES AWAY THIS MASK YOU HAVE PROVIDED.  THE
KERNEL WILL USE THIS INFORMATION LATER WHEN YOU MAKE DMA MAPPINGS.

THERE IS A CASE WHICH WE ARE AWARE OF AT THIS TIME, WHICH IS WORTH
MENTIONING IN THIS DOCUMENTATION.  IF YOUR DEVICE SUPPORTS MULTIPLE
FUNCTIONS (FOR EXAMPLE A SOUND CARD PROVIDES PLAYBACK AND RECORD
FUNCTIONS) AND THE VARIOUS DIFFERENT FUNCTIONS HAVE _DIFFERENT_
DMA ADDRESSING LIMITATIONS, YOU MAY WISH TO PROBE EACH MASK AND
ONLY PROVIDE THE FUNCTIONALITY WHICH THE MACHINE CAN HANDLE.  IT
IS IMPORTANT THAT THE LAST CALL TO DMA_SET_MASK() BE FOR THE
MOST SPECIFIC MASK.

HERE IS PSEUDO-CODE SHOWING HOW THIS MIGHT BE DONE::

	#DEFINE PLAYBACK_ADDRESS_BITS	DMA_BIT_MASK(32)
	#DEFINE RECORD_ADDRESS_BITS	DMA_BIT_MASK(24)

	STRUCT MY_SOUND_CARD *CARD;
	STRUCT DEVICE *DEV;

	...
	IF (!DMA_SET_MASK(DEV, PLAYBACK_ADDRESS_BITS)) {
		CARD->PLAYBACK_ENABLED = 1;
	} ELSE {
		CARD->PLAYBACK_ENABLED = 0;
		DEV_WARN(DEV, "%S: PLAYBACK DISABLED DUE TO DMA LIMITATIONS\N",
		       CARD->NAME);
	}
	IF (!DMA_SET_MASK(DEV, RECORD_ADDRESS_BITS)) {
		CARD->RECORD_ENABLED = 1;
	} ELSE {
		CARD->RECORD_ENABLED = 0;
		DEV_WARN(DEV, "%S: RECORD DISABLED DUE TO DMA LIMITATIONS\N",
		       CARD->NAME);
	}

A SOUND CARD WAS USED AS AN EXAMPLE HERE BECAUSE THIS GENRE OF PCI
DEVICES SEEMS TO BE LITTERED WITH ISA CHIPS GIVEN A PCI FRONT END,
AND THUS RETAINING THE 16MB DMA ADDRESSING LIMITATIONS OF ISA.

TYPES OF DMA MAPPINGS
=====================

THERE ARE TWO TYPES OF DMA MAPPINGS:

- CONSISTENT DMA MAPPINGS WHICH ARE USUALLY MAPPED AT DRIVER
  INITIALIZATION, UNMAPPED AT THE END AND FOR WHICH THE HARDWARE SHOULD
  GUARANTEE THAT THE DEVICE AND THE CPU CAN ACCESS THE DATA
  IN PARALLEL AND WILL SEE UPDATES MADE BY EACH OTHER WITHOUT ANY
  EXPLICIT SOFTWARE FLUSHING.

  THINK OF "CONSISTENT" AS "SYNCHRONOUS" OR "COHERENT".

  THE CURRENT DEFAULT IS TO RETURN CONSISTENT MEMORY IN THE LOW 32
  BITS OF THE DMA SPACE.  HOWEVER, FOR FUTURE COMPATIBILITY YOU SHOULD
  SET THE CONSISTENT MASK EVEN IF THIS DEFAULT IS FINE FOR YOUR
  DRIVER.

  GOOD EXAMPLES OF WHAT TO USE CONSISTENT MAPPINGS FOR ARE:

	- NETWORK CARD DMA RING DESCRIPTORS.
	- SCSI ADAPTER MAILBOX COMMAND DATA STRUCTURES.
	- DEVICE FIRMWARE MICROCODE EXECUTED OUT OF
	  MAIN MEMORY.

  THE INVARIANT THESE EXAMPLES ALL REQUIRE IS THAT ANY CPU STORE
  TO MEMORY IS IMMEDIATELY VISIBLE TO THE DEVICE, AND VICE
  VERSA.  CONSISTENT MAPPINGS GUARANTEE THIS.

  .. IMPORTANT::

	     CONSISTENT DMA MEMORY DOES NOT PRECLUDE THE USAGE OF
	     PROPER MEMORY BARRIERS.  THE CPU MAY REORDER STORES TO
	     CONSISTENT MEMORY JUST AS IT MAY NORMAL MEMORY.  EXAMPLE:
	     IF IT IS IMPORTANT FOR THE DEVICE TO SEE THE FIRST WORD
	     OF A DESCRIPTOR UPDATED BEFORE THE SECOND, YOU MUST DO
	     SOMETHING LIKE::

		DESC->WORD0 = ADDRESS;
		WMB();
		DESC->WORD1 = DESC_VALID;

             IN ORDER TO GET CORRECT BEHAVIOR ON ALL PLATFORMS.

	     ALSO, ON SOME PLATFORMS YOUR DRIVER MAY NEED TO FLUSH CPU WRITE
	     BUFFERS IN MUCH THE SAME WAY AS IT NEEDS TO FLUSH WRITE BUFFERS
	     FOUND IN PCI BRIDGES (SUCH AS BY READING A REGISTER'S VALUE
	     AFTER WRITING IT).

- STREAMING DMA MAPPINGS WHICH ARE USUALLY MAPPED FOR ONE DMA
  TRANSFER, UNMAPPED RIGHT AFTER IT (UNLESS YOU USE DMA_SYNC_* BELOW)
  AND FOR WHICH HARDWARE CAN OPTIMIZE FOR SEQUENTIAL ACCESSES.

  THINK OF "STREAMING" AS "ASYNCHRONOUS" OR "OUTSIDE THE COHERENCY
  DOMAIN".

  GOOD EXAMPLES OF WHAT TO USE STREAMING MAPPINGS FOR ARE:

	- NETWORKING BUFFERS TRANSMITTED/RECEIVED BY A DEVICE.
	- FILESYSTEM BUFFERS WRITTEN/READ BY A SCSI DEVICE.

  THE INTERFACES FOR USING THIS TYPE OF MAPPING WERE DESIGNED IN
  SUCH A WAY THAT AN IMPLEMENTATION CAN MAKE WHATEVER PERFORMANCE
  OPTIMIZATIONS THE HARDWARE ALLOWS.  TO THIS END, WHEN USING
  SUCH MAPPINGS YOU MUST BE EXPLICIT ABOUT WHAT YOU WANT TO HAPPEN.

NEITHER TYPE OF DMA MAPPING HAS ALIGNMENT RESTRICTIONS THAT COME FROM
THE UNDERLYING BUS, ALTHOUGH SOME DEVICES MAY HAVE SUCH RESTRICTIONS.
ALSO, SYSTEMS WITH CACHES THAT AREN'T DMA-COHERENT WILL WORK BETTER
WHEN THE UNDERLYING BUFFERS DON'T SHARE CACHE LINES WITH OTHER DATA.


USING CONSISTENT DMA MAPPINGS
=============================

TO ALLOCATE AND MAP LARGE (PAGE_SIZE OR SO) CONSISTENT DMA REGIONS,
YOU SHOULD DO::

	DMA_ADDR_T DMA_HANDLE;

	CPU_ADDR = DMA_ALLOC_COHERENT(DEV, SIZE, &DMA_HANDLE, GFP);

WHERE DEVICE IS A ``STRUCT DEVICE *``. THIS MAY BE CALLED IN INTERRUPT
CONTEXT WITH THE GFP_ATOMIC FLAG.

SIZE IS THE LENGTH OF THE REGION YOU WANT TO ALLOCATE, IN BYTES.

THIS ROUTINE WILL ALLOCATE RAM FOR THAT REGION, SO IT ACTS SIMILARLY TO
__GET_FREE_PAGES() (BUT TAKES SIZE INSTEAD OF A PAGE ORDER).  IF YOUR
DRIVER NEEDS REGIONS SIZED SMALLER THAN A PAGE, YOU MAY PREFER USING
THE DMA_POOL INTERFACE, DESCRIBED BELOW.

THE CONSISTENT DMA MAPPING INTERFACES, WILL BY DEFAULT RETURN A DMA ADDRESS
WHICH IS 32-BIT ADDRESSABLE.  EVEN IF THE DEVICE INDICATES (VIA THE DMA MASK)
THAT IT MAY ADDRESS THE UPPER 32-BITS, CONSISTENT ALLOCATION WILL ONLY
RETURN > 32-BIT ADDRESSES FOR DMA IF THE CONSISTENT DMA MASK HAS BEEN
EXPLICITLY CHANGED VIA DMA_SET_COHERENT_MASK().  THIS IS TRUE OF THE
DMA_POOL INTERFACE AS WELL.

DMA_ALLOC_COHERENT() RETURNS TWO VALUES: THE VIRTUAL ADDRESS WHICH YOU
CAN USE TO ACCESS IT FROM THE CPU AND DMA_HANDLE WHICH YOU PASS TO THE
CARD.

THE CPU VIRTUAL ADDRESS AND THE DMA ADDRESS ARE BOTH
GUARANTEED TO BE ALIGNED TO THE SMALLEST PAGE_SIZE ORDER WHICH
IS GREATER THAN OR EQUAL TO THE REQUESTED SIZE.  THIS INVARIANT
EXISTS (FOR EXAMPLE) TO GUARANTEE THAT IF YOU ALLOCATE A CHUNK
WHICH IS SMALLER THAN OR EQUAL TO 64 KILOBYTES, THE EXTENT OF THE
BUFFER YOU RECEIVE WILL NOT CROSS A 64K BOUNDARY.

TO UNMAP AND FREE SUCH A DMA REGION, YOU CALL::

	DMA_FREE_COHERENT(DEV, SIZE, CPU_ADDR, DMA_HANDLE);

WHERE DEV, SIZE ARE THE SAME AS IN THE ABOVE CALL AND CPU_ADDR AND
DMA_HANDLE ARE THE VALUES DMA_ALLOC_COHERENT() RETURNED TO YOU.
THIS FUNCTION MAY NOT BE CALLED IN INTERRUPT CONTEXT.

IF YOUR DRIVER NEEDS LOTS OF SMALLER MEMORY REGIONS, YOU CAN WRITE
CUSTOM CODE TO SUBDIVIDE PAGES RETURNED BY DMA_ALLOC_COHERENT(),
OR YOU CAN USE THE DMA_POOL API TO DO THAT.  A DMA_POOL IS LIKE
A KMEM_CACHE, BUT IT USES DMA_ALLOC_COHERENT(), NOT __GET_FREE_PAGES().
ALSO, IT UNDERSTANDS COMMON HARDWARE CONSTRAINTS FOR ALIGNMENT,
LIKE QUEUE HEADS NEEDING TO BE ALIGNED ON N BYTE BOUNDARIES.

CREATE A DMA_POOL LIKE THIS::

	STRUCT DMA_POOL *POOL;

	POOL = DMA_POOL_CREATE(NAME, DEV, SIZE, ALIGN, BOUNDARY);

THE "NAME" IS FOR DIAGNOSTICS (LIKE A KMEM_CACHE NAME); DEV AND SIZE
ARE AS ABOVE.  THE DEVICE'S HARDWARE ALIGNMENT REQUIREMENT FOR THIS
TYPE OF DATA IS "ALIGN" (WHICH IS EXPRESSED IN BYTES, AND MUST BE A
POWER OF TWO).  IF YOUR DEVICE HAS NO BOUNDARY CROSSING RESTRICTIONS,
PASS 0 FOR BOUNDARY; PASSING 4096 SAYS MEMORY ALLOCATED FROM THIS POOL
MUST NOT CROSS 4KBYTE BOUNDARIES (BUT AT THAT TIME IT MAY BE BETTER TO
USE DMA_ALLOC_COHERENT() DIRECTLY INSTEAD).

ALLOCATE MEMORY FROM A DMA POOL LIKE THIS::

	CPU_ADDR = DMA_POOL_ALLOC(POOL, FLAGS, &DMA_HANDLE);

FLAGS ARE GFP_KERNEL IF BLOCKING IS PERMITTED (NOT IN_INTERRUPT NOR
HOLDING SMP LOCKS), GFP_ATOMIC OTHERWISE.  LIKE DMA_ALLOC_COHERENT(),
THIS RETURNS TWO VALUES, CPU_ADDR AND DMA_HANDLE.

FREE MEMORY THAT WAS ALLOCATED FROM A DMA_POOL LIKE THIS::

	DMA_POOL_FREE(POOL, CPU_ADDR, DMA_HANDLE);

WHERE POOL IS WHAT YOU PASSED TO DMA_POOL_ALLOC(), AND CPU_ADDR AND
DMA_HANDLE ARE THE VALUES DMA_POOL_ALLOC() RETURNED. THIS FUNCTION
MAY BE CALLED IN INTERRUPT CONTEXT.

DESTROY A DMA_POOL BY CALLING::

	DMA_POOL_DESTROY(POOL);

MAKE SURE YOU'VE CALLED DMA_POOL_FREE() FOR ALL MEMORY ALLOCATED
FROM A POOL BEFORE YOU DESTROY THE POOL. THIS FUNCTION MAY NOT
BE CALLED IN INTERRUPT CONTEXT.

DMA DIRECTION
=============

THE INTERFACES DESCRIBED IN SUBSEQUENT PORTIONS OF THIS DOCUMENT
TAKE A DMA DIRECTION ARGUMENT, WHICH IS AN INTEGER AND TAKES ON
ONE OF THE FOLLOWING VALUES::

 DMA_BIDIRECTIONAL
 DMA_TO_DEVICE
 DMA_FROM_DEVICE
 DMA_NONE

YOU SHOULD PROVIDE THE EXACT DMA DIRECTION IF YOU KNOW IT.

DMA_TO_DEVICE MEANS "FROM MAIN MEMORY TO THE DEVICE"
DMA_FROM_DEVICE MEANS "FROM THE DEVICE TO MAIN MEMORY"
IT IS THE DIRECTION IN WHICH THE DATA MOVES DURING THE DMA
TRANSFER.

YOU ARE _STRONGLY_ ENCOURAGED TO SPECIFY THIS AS PRECISELY
AS YOU POSSIBLY CAN.

IF YOU ABSOLUTELY CANNOT KNOW THE DIRECTION OF THE DMA TRANSFER,
SPECIFY DMA_BIDIRECTIONAL.  IT MEANS THAT THE DMA CAN GO IN
EITHER DIRECTION.  THE PLATFORM GUARANTEES THAT YOU MAY LEGALLY
SPECIFY THIS, AND THAT IT WILL WORK, BUT THIS MAY BE AT THE
COST OF PERFORMANCE FOR EXAMPLE.

THE VALUE DMA_NONE IS TO BE USED FOR DEBUGGING.  ONE CAN
HOLD THIS IN A DATA STRUCTURE BEFORE YOU COME TO KNOW THE
PRECISE DIRECTION, AND THIS WILL HELP CATCH CASES WHERE YOUR
DIRECTION TRACKING LOGIC HAS FAILED TO SET THINGS UP PROPERLY.

ANOTHER ADVANTAGE OF SPECIFYING THIS VALUE PRECISELY (OUTSIDE OF
POTENTIAL PLATFORM-SPECIFIC OPTIMIZATIONS OF SUCH) IS FOR DEBUGGING.
SOME PLATFORMS ACTUALLY HAVE A WRITE PERMISSION BOOLEAN WHICH DMA
MAPPINGS CAN BE MARKED WITH, MUCH LIKE PAGE PROTECTIONS IN THE USER
PROGRAM ADDRESS SPACE.  SUCH PLATFORMS CAN AND DO REPORT ERRORS IN THE
KERNEL LOGS WHEN THE DMA CONTROLLER HARDWARE DETECTS VIOLATION OF THE
PERMISSION SETTING.

ONLY STREAMING MAPPINGS SPECIFY A DIRECTION, CONSISTENT MAPPINGS
IMPLICITLY HAVE A DIRECTION ATTRIBUTE SETTING OF
DMA_BIDIRECTIONAL.

THE SCSI SUBSYSTEM TELLS YOU THE DIRECTION TO USE IN THE
'SC_DATA_DIRECTION' MEMBER OF THE SCSI COMMAND YOUR DRIVER IS
WORKING ON.

FOR NETWORKING DRIVERS, IT'S A RATHER SIMPLE AFFAIR.  FOR TRANSMIT
PACKETS, MAP/UNMAP THEM WITH THE DMA_TO_DEVICE DIRECTION
SPECIFIER.  FOR RECEIVE PACKETS, JUST THE OPPOSITE, MAP/UNMAP THEM
WITH THE DMA_FROM_DEVICE DIRECTION SPECIFIER.

USING STREAMING DMA MAPPINGS
============================

THE STREAMING DMA MAPPING ROUTINES CAN BE CALLED FROM INTERRUPT
CONTEXT.  THERE ARE TWO VERSIONS OF EACH MAP/UNMAP, ONE WHICH WILL
MAP/UNMAP A SINGLE MEMORY REGION, AND ONE WHICH WILL MAP/UNMAP A
SCATTERLIST.

TO MAP A SINGLE REGION, YOU DO::

	STRUCT DEVICE *DEV = &MY_DEV->DEV;
	DMA_ADDR_T DMA_HANDLE;
	VOID *ADDR = BUFFER->PTR;
	SIZE_T SIZE = BUFFER->LEN;

	DMA_HANDLE = DMA_MAP_SINGLE(DEV, ADDR, SIZE, DIRECTION);
	IF (DMA_MAPPING_ERROR(DEV, DMA_HANDLE)) {
		/*
		 * REDUCE CURRENT DMA MAPPING USAGE,
		 * DELAY AND TRY AGAIN LATER OR
		 * RESET DRIVER.
		 */
		GOTO MAP_ERROR_HANDLING;
	}

AND TO UNMAP IT::

	DMA_UNMAP_SINGLE(DEV, DMA_HANDLE, SIZE, DIRECTION);

YOU SHOULD CALL DMA_MAPPING_ERROR() AS DMA_MAP_SINGLE() COULD FAIL AND RETURN
ERROR.  DOING SO WILL ENSURE THAT THE MAPPING CODE WILL WORK CORRECTLY ON ALL
DMA IMPLEMENTATIONS WITHOUT ANY DEPENDENCY ON THE SPECIFICS OF THE UNDERLYING
IMPLEMENTATION. USING THE RETURNED ADDRESS WITHOUT CHECKING FOR ERRORS COULD
RESULT IN FAILURES RANGING FROM PANICS TO SILENT DATA CORRUPTION.  THE SAME
APPLIES TO DMA_MAP_PAGE() AS WELL.

YOU SHOULD CALL DMA_UNMAP_SINGLE() WHEN THE DMA ACTIVITY IS FINISHED, E.G.,
FROM THE INTERRUPT WHICH TOLD YOU THAT THE DMA TRANSFER IS DONE.

USING CPU POINTERS LIKE THIS FOR SINGLE MAPPINGS HAS A DISADVANTAGE:
YOU CANNOT REFERENCE HIGHMEM MEMORY IN THIS WAY.  THUS, THERE IS A
MAP/UNMAP INTERFACE PAIR AKIN TO DMA_{MAP,UNMAP}_SINGLE().  THESE
INTERFACES DEAL WITH PAGE/OFFSET PAIRS INSTEAD OF CPU POINTERS.
SPECIFICALLY::

	STRUCT DEVICE *DEV = &MY_DEV->DEV;
	DMA_ADDR_T DMA_HANDLE;
	STRUCT PAGE *PAGE = BUFFER->PAGE;
	UNSIGNED LONG OFFSET = BUFFER->OFFSET;
	SIZE_T SIZE = BUFFER->LEN;

	DMA_HANDLE = DMA_MAP_PAGE(DEV, PAGE, OFFSET, SIZE, DIRECTION);
	IF (DMA_MAPPING_ERROR(DEV, DMA_HANDLE)) {
		/*
		 * REDUCE CURRENT DMA MAPPING USAGE,
		 * DELAY AND TRY AGAIN LATER OR
		 * RESET DRIVER.
		 */
		GOTO MAP_ERROR_HANDLING;
	}

	...

	DMA_UNMAP_PAGE(DEV, DMA_HANDLE, SIZE, DIRECTION);

HERE, "OFFSET" MEANS BYTE OFFSET WITHIN THE GIVEN PAGE.

YOU SHOULD CALL DMA_MAPPING_ERROR() AS DMA_MAP_PAGE() COULD FAIL AND RETURN
ERROR AS OUTLINED UNDER THE DMA_MAP_SINGLE() DISCUSSION.

YOU SHOULD CALL DMA_UNMAP_PAGE() WHEN THE DMA ACTIVITY IS FINISHED, E.G.,
FROM THE INTERRUPT WHICH TOLD YOU THAT THE DMA TRANSFER IS DONE.

WITH SCATTERLISTS, YOU MAP A REGION GATHERED FROM SEVERAL REGIONS BY::

	INT I, COUNT = DMA_MAP_SG(DEV, SGLIST, NENTS, DIRECTION);
	STRUCT SCATTERLIST *SG;

	FOR_EACH_SG(SGLIST, SG, COUNT, I) {
		HW_ADDRESS[I] = SG_DMA_ADDRESS(SG);
		HW_LEN[I] = SG_DMA_LEN(SG);
	}

WHERE NENTS IS THE NUMBER OF ENTRIES IN THE SGLIST.

THE IMPLEMENTATION IS FREE TO MERGE SEVERAL CONSECUTIVE SGLIST ENTRIES
INTO ONE (E.G. IF DMA MAPPING IS DONE WITH PAGE_SIZE GRANULARITY, ANY
CONSECUTIVE SGLIST ENTRIES CAN BE MERGED INTO ONE PROVIDED THE FIRST ONE
ENDS AND THE SECOND ONE STARTS ON A PAGE BOUNDARY - IN FACT THIS IS A HUGE
ADVANTAGE FOR CARDS WHICH EITHER CANNOT DO SCATTER-GATHER OR HAVE VERY
LIMITED NUMBER OF SCATTER-GATHER ENTRIES) AND RETURNS THE ACTUAL NUMBER
OF SG ENTRIES IT MAPPED THEM TO. ON FAILURE 0 IS RETURNED.

THEN YOU SHOULD LOOP COUNT TIMES (NOTE: THIS CAN BE LESS THAN NENTS TIMES)
AND USE SG_DMA_ADDRESS() AND SG_DMA_LEN() MACROS WHERE YOU PREVIOUSLY
ACCESSED SG->ADDRESS AND SG->LENGTH AS SHOWN ABOVE.

TO UNMAP A SCATTERLIST, JUST CALL::

	DMA_UNMAP_SG(DEV, SGLIST, NENTS, DIRECTION);

AGAIN, MAKE SURE DMA ACTIVITY HAS ALREADY FINISHED.

.. NOTE::

	THE 'NENTS' ARGUMENT TO THE DMA_UNMAP_SG CALL MUST BE
	THE _SAME_ ONE YOU PASSED INTO THE DMA_MAP_SG CALL,
	IT SHOULD _NOT_ BE THE 'COUNT' VALUE _RETURNED_ FROM THE
	DMA_MAP_SG CALL.

EVERY DMA_MAP_{SINGLE,SG}() CALL SHOULD HAVE ITS DMA_UNMAP_{SINGLE,SG}()
COUNTERPART, BECAUSE THE DMA ADDRESS SPACE IS A SHARED RESOURCE AND
YOU COULD RENDER THE MACHINE UNUSABLE BY CONSUMING ALL DMA ADDRESSES.

IF YOU NEED TO USE THE SAME STREAMING DMA REGION MULTIPLE TIMES AND TOUCH
THE DATA IN BETWEEN THE DMA TRANSFERS, THE BUFFER NEEDS TO BE SYNCED
PROPERLY IN ORDER FOR THE CPU AND DEVICE TO SEE THE MOST UP-TO-DATE AND
CORRECT COPY OF THE DMA BUFFER.

SO, FIRSTLY, JUST MAP IT WITH DMA_MAP_{SINGLE,SG}(), AND AFTER EACH DMA
TRANSFER CALL EITHER::

	DMA_SYNC_SINGLE_FOR_CPU(DEV, DMA_HANDLE, SIZE, DIRECTION);

OR::

	DMA_SYNC_SG_FOR_CPU(DEV, SGLIST, NENTS, DIRECTION);

AS APPROPRIATE.

THEN, IF YOU WISH TO LET THE DEVICE GET AT THE DMA AREA AGAIN,
FINISH ACCESSING THE DATA WITH THE CPU, AND THEN BEFORE ACTUALLY
GIVING THE BUFFER TO THE HARDWARE CALL EITHER::

	DMA_SYNC_SINGLE_FOR_DEVICE(DEV, DMA_HANDLE, SIZE, DIRECTION);

OR::

	DMA_SYNC_SG_FOR_DEVICE(DEV, SGLIST, NENTS, DIRECTION);

AS APPROPRIATE.

.. NOTE::

	      THE 'NENTS' ARGUMENT TO DMA_SYNC_SG_FOR_CPU() AND
	      DMA_SYNC_SG_FOR_DEVICE() MUST BE THE SAME PASSED TO
	      DMA_MAP_SG(). IT IS _NOT_ THE COUNT RETURNED BY
	      DMA_MAP_SG().

AFTER THE LAST DMA TRANSFER CALL ONE OF THE DMA UNMAP ROUTINES
DMA_UNMAP_{SINGLE,SG}(). IF YOU DON'T TOUCH THE DATA FROM THE FIRST
DMA_MAP_*() CALL TILL DMA_UNMAP_*(), THEN YOU DON'T HAVE TO CALL THE
DMA_SYNC_*() ROUTINES AT ALL.

HERE IS PSEUDO CODE WHICH SHOWS A SITUATION IN WHICH YOU WOULD NEED
TO USE THE DMA_SYNC_*() INTERFACES::

	MY_CARD_SETUP_RECEIVE_BUFFER(STRUCT MY_CARD *CP, CHAR *BUFFER, INT LEN)
	{
		DMA_ADDR_T MAPPING;

		MAPPING = DMA_MAP_SINGLE(CP->DEV, BUFFER, LEN, DMA_FROM_DEVICE);
		IF (DMA_MAPPING_ERROR(CP->DEV, MAPPING)) {
			/*
			 * REDUCE CURRENT DMA MAPPING USAGE,
			 * DELAY AND TRY AGAIN LATER OR
			 * RESET DRIVER.
			 */
			GOTO MAP_ERROR_HANDLING;
		}

		CP->RX_BUF = BUFFER;
		CP->RX_LEN = LEN;
		CP->RX_DMA = MAPPING;

		GIVE_RX_BUF_TO_CARD(CP);
	}

	...

	MY_CARD_INTERRUPT_HANDLER(INT IRQ, VOID *DEVID, STRUCT PT_REGS *REGS)
	{
		STRUCT MY_CARD *CP = DEVID;

		...
		IF (READ_CARD_STATUS(CP) == RX_BUF_TRANSFERRED) {
			STRUCT MY_CARD_HEADER *HP;

			/* EXAMINE THE HEADER TO SEE IF WE WISH
			 * TO ACCEPT THE DATA.  BUT SYNCHRONIZE
			 * THE DMA TRANSFER WITH THE CPU FIRST
			 * SO THAT WE SEE UPDATED CONTENTS.
			 */
			DMA_SYNC_SINGLE_FOR_CPU(&CP->DEV, CP->RX_DMA,
						CP->RX_LEN,
						DMA_FROM_DEVICE);

			/* NOW IT IS SAFE TO EXAMINE THE BUFFER. */
			HP = (STRUCT MY_CARD_HEADER *) CP->RX_BUF;
			IF (HEADER_IS_OK(HP)) {
				DMA_UNMAP_SINGLE(&CP->DEV, CP->RX_DMA, CP->RX_LEN,
						 DMA_FROM_DEVICE);
				PASS_TO_UPPER_LAYERS(CP->RX_BUF);
				MAKE_AND_SETUP_NEW_RX_BUF(CP);
			} ELSE {
				/* CPU SHOULD NOT WRITE TO
				 * DMA_FROM_DEVICE-MAPPED AREA,
				 * SO DMA_SYNC_SINGLE_FOR_DEVICE() IS
				 * NOT NEEDED HERE. IT WOULD BE REQUIRED
				 * FOR DMA_BIDIRECTIONAL MAPPING IF
				 * THE MEMORY WAS MODIFIED.
				 */
				GIVE_RX_BUF_TO_CARD(CP);
			}
		}
	}

DRIVERS CONVERTED FULLY TO THIS INTERFACE SHOULD NOT USE VIRT_TO_BUS() ANY
LONGER, NOR SHOULD THEY USE BUS_TO_VIRT(). SOME DRIVERS HAVE TO BE CHANGED A
LITTLE BIT, BECAUSE THERE IS NO LONGER AN EQUIVALENT TO BUS_TO_VIRT() IN THE
DYNAMIC DMA MAPPING SCHEME - YOU HAVE TO ALWAYS STORE THE DMA ADDRESSES
RETURNED BY THE DMA_ALLOC_COHERENT(), DMA_POOL_ALLOC(), AND DMA_MAP_SINGLE()
CALLS (DMA_MAP_SG() STORES THEM IN THE SCATTERLIST ITSELF IF THE PLATFORM
SUPPORTS DYNAMIC DMA MAPPING IN HARDWARE) IN YOUR DRIVER STRUCTURES AND/OR
IN THE CARD REGISTERS.

ALL DRIVERS SHOULD BE USING THESE INTERFACES WITH NO EXCEPTIONS.  IT
IS PLANNED TO COMPLETELY REMOVE VIRT_TO_BUS() AND BUS_TO_VIRT() AS
THEY ARE ENTIRELY DEPRECATED.  SOME PORTS ALREADY DO NOT PROVIDE THESE
AS IT IS IMPOSSIBLE TO CORRECTLY SUPPORT THEM.

HANDLING ERRORS
===============

DMA ADDRESS SPACE IS LIMITED ON SOME ARCHITECTURES AND AN ALLOCATION
FAILURE CAN BE DETERMINED BY:

- CHECKING IF DMA_ALLOC_COHERENT() RETURNS NULL OR DMA_MAP_SG RETURNS 0

- CHECKING THE DMA_ADDR_T RETURNED FROM DMA_MAP_SINGLE() AND DMA_MAP_PAGE()
  BY USING DMA_MAPPING_ERROR()::

	DMA_ADDR_T DMA_HANDLE;

	DMA_HANDLE = DMA_MAP_SINGLE(DEV, ADDR, SIZE, DIRECTION);
	IF (DMA_MAPPING_ERROR(DEV, DMA_HANDLE)) {
		/*
		 * REDUCE CURRENT DMA MAPPING USAGE,
		 * DELAY AND TRY AGAIN LATER OR
		 * RESET DRIVER.
		 */
		GOTO MAP_ERROR_HANDLING;
	}

- UNMAP PAGES THAT ARE ALREADY MAPPED, WHEN MAPPING ERROR OCCURS IN THE MIDDLE
  OF A MULTIPLE PAGE MAPPING ATTEMPT. THESE EXAMPLE ARE APPLICABLE TO
  DMA_MAP_PAGE() AS WELL.

EXAMPLE 1::

	DMA_ADDR_T DMA_HANDLE1;
	DMA_ADDR_T DMA_HANDLE2;

	DMA_HANDLE1 = DMA_MAP_SINGLE(DEV, ADDR, SIZE, DIRECTION);
	IF (DMA_MAPPING_ERROR(DEV, DMA_HANDLE1)) {
		/*
		 * REDUCE CURRENT DMA MAPPING USAGE,
		 * DELAY AND TRY AGAIN LATER OR
		 * RESET DRIVER.
		 */
		GOTO MAP_ERROR_HANDLING1;
	}
	DMA_HANDLE2 = DMA_MAP_SINGLE(DEV, ADDR, SIZE, DIRECTION);
	IF (DMA_MAPPING_ERROR(DEV, DMA_HANDLE2)) {
		/*
		 * REDUCE CURRENT DMA MAPPING USAGE,
		 * DELAY AND TRY AGAIN LATER OR
		 * RESET DRIVER.
		 */
		GOTO MAP_ERROR_HANDLING2;
	}

	...

	MAP_ERROR_HANDLING2:
		DMA_UNMAP_SINGLE(DMA_HANDLE1);
	MAP_ERROR_HANDLING1:

EXAMPLE 2::

	/*
	 * IF BUFFERS ARE ALLOCATED IN A LOOP, UNMAP ALL MAPPED BUFFERS WHEN
	 * MAPPING ERROR IS DETECTED IN THE MIDDLE
	 */

	DMA_ADDR_T DMA_ADDR;
	DMA_ADDR_T ARRAY[DMA_BUFFERS];
	INT SAVE_INDEX = 0;

	FOR (I = 0; I < DMA_BUFFERS; I++) {

		...

		DMA_ADDR = DMA_MAP_SINGLE(DEV, ADDR, SIZE, DIRECTION);
		IF (DMA_MAPPING_ERROR(DEV, DMA_ADDR)) {
			/*
			 * REDUCE CURRENT DMA MAPPING USAGE,
			 * DELAY AND TRY AGAIN LATER OR
			 * RESET DRIVER.
			 */
			GOTO MAP_ERROR_HANDLING;
		}
		ARRAY[I].DMA_ADDR = DMA_ADDR;
		SAVE_INDEX++;
	}

	...

	MAP_ERROR_HANDLING:

	FOR (I = 0; I < SAVE_INDEX; I++) {

		...

		DMA_UNMAP_SINGLE(ARRAY[I].DMA_ADDR);
	}

NETWORKING DRIVERS MUST CALL DEV_KFREE_SKB() TO FREE THE SOCKET BUFFER
AND RETURN NETDEV_TX_OK IF THE DMA MAPPING FAILS ON THE TRANSMIT HOOK
(NDO_START_XMIT). THIS MEANS THAT THE SOCKET BUFFER IS JUST DROPPED IN
THE FAILURE CASE.

SCSI DRIVERS MUST RETURN SCSI_MLQUEUE_HOST_BUSY IF THE DMA MAPPING
FAILS IN THE QUEUECOMMAND HOOK. THIS MEANS THAT THE SCSI SUBSYSTEM
PASSES THE COMMAND TO THE DRIVER AGAIN LATER.

OPTIMIZING UNMAP STATE SPACE CONSUMPTION
========================================

ON MANY PLATFORMS, DMA_UNMAP_{SINGLE,PAGE}() IS SIMPLY A NOP.
THEREFORE, KEEPING TRACK OF THE MAPPING ADDRESS AND LENGTH IS A WASTE
OF SPACE.  INSTEAD OF FILLING YOUR DRIVERS UP WITH IFDEFS AND THE LIKE
TO "WORK AROUND" THIS (WHICH WOULD DEFEAT THE WHOLE PURPOSE OF A
PORTABLE API) THE FOLLOWING FACILITIES ARE PROVIDED.

ACTUALLY, INSTEAD OF DESCRIBING THE MACROS ONE BY ONE, WE'LL
TRANSFORM SOME EXAMPLE CODE.

1) USE DEFINE_DMA_UNMAP_{ADDR,LEN} IN STATE SAVING STRUCTURES.
   EXAMPLE, BEFORE::

	STRUCT RING_STATE {
		STRUCT SK_BUFF *SKB;
		DMA_ADDR_T MAPPING;
		__U32 LEN;
	};

   AFTER::

	STRUCT RING_STATE {
		STRUCT SK_BUFF *SKB;
		DEFINE_DMA_UNMAP_ADDR(MAPPING);
		DEFINE_DMA_UNMAP_LEN(LEN);
	};

2) USE DMA_UNMAP_{ADDR,LEN}_SET() TO SET THESE VALUES.
   EXAMPLE, BEFORE::

	RINGP->MAPPING = FOO;
	RINGP->LEN = BAR;

   AFTER::

	DMA_UNMAP_ADDR_SET(RINGP, MAPPING, FOO);
	DMA_UNMAP_LEN_SET(RINGP, LEN, BAR);

3) USE DMA_UNMAP_{ADDR,LEN}() TO ACCESS THESE VALUES.
   EXAMPLE, BEFORE::

	DMA_UNMAP_SINGLE(DEV, RINGP->MAPPING, RINGP->LEN,
			 DMA_FROM_DEVICE);

   AFTER::

	DMA_UNMAP_SINGLE(DEV,
			 DMA_UNMAP_ADDR(RINGP, MAPPING),
			 DMA_UNMAP_LEN(RINGP, LEN),
			 DMA_FROM_DEVICE);

IT REALLY SHOULD BE SELF-EXPLANATORY.  WE TREAT THE ADDR AND LEN
SEPARATELY, BECAUSE IT IS POSSIBLE FOR AN IMPLEMENTATION TO ONLY
NEED THE ADDRESS IN ORDER TO PERFORM THE UNMAP OPERATION.

PLATFORM ISSUES
===============

IF YOU ARE JUST WRITING DRIVERS FOR LINUX AND DO NOT MAINTAIN
AN ARCHITECTURE PORT FOR THE KERNEL, YOU CAN SAFELY SKIP DOWN
TO "CLOSING".

1) STRUCT SCATTERLIST REQUIREMENTS.

   YOU NEED TO ENABLE CONFIG_NEED_SG_DMA_LENGTH IF THE ARCHITECTURE
   SUPPORTS IOMMUS (INCLUDING SOFTWARE IOMMU).

2) ARCH_DMA_MINALIGN

   ARCHITECTURES MUST ENSURE THAT KMALLOC'ED BUFFER IS
   DMA-SAFE. DRIVERS AND SUBSYSTEMS DEPEND ON IT. IF AN ARCHITECTURE
   ISN'T FULLY DMA-COHERENT (I.E. HARDWARE DOESN'T ENSURE THAT DATA IN
   THE CPU CACHE IS IDENTICAL TO DATA IN MAIN MEMORY),
   ARCH_DMA_MINALIGN MUST BE SET SO THAT THE MEMORY ALLOCATOR
   MAKES SURE THAT KMALLOC'ED BUFFER DOESN'T SHARE A CACHE LINE WITH
   THE OTHERS. SEE ARCH/ARM/INCLUDE/ASM/CACHE.H AS AN EXAMPLE.

   NOTE THAT ARCH_DMA_MINALIGN IS ABOUT DMA MEMORY ALIGNMENT
   CONSTRAINTS. YOU DON'T NEED TO WORRY ABOUT THE ARCHITECTURE DATA
   ALIGNMENT CONSTRAINTS (E.G. THE ALIGNMENT CONSTRAINTS ABOUT 64-BIT
   OBJECTS).

CLOSING
=======

THIS DOCUMENT, AND THE API ITSELF, WOULD NOT BE IN ITS CURRENT
FORM WITHOUT THE FEEDBACK AND SUGGESTIONS FROM NUMEROUS INDIVIDUALS.
WE WOULD LIKE TO SPECIFICALLY MENTION, IN NO PARTICULAR ORDER, THE
FOLLOWING PEOPLE::

	RUSSELL KING <RMK@ARM.LINUX.ORG.UK>
	LEO DAGUM <DAGUM@BARREL.ENGR.SGI.COM>
	RALF BAECHLE <RALF@OSS.SGI.COM>
	GRANT GRUNDLER <GRUNDLER@CUP.HP.COM>
	JAY ESTABROOK <JAY.ESTABROOK@COMPAQ.COM>
	THOMAS SAILER <SAILER@IFE.EE.ETHZ.CH>
	ANDREA ARCANGELI <ANDREA@SUSE.DE>
	JENS AXBOE <JENS.AXBOE@ORACLE.COM>
	DAVID MOSBERGER-TANG <DAVIDM@HPL.HP.COM>

=========================
DYNAMIC DMA MAPPING GUIDE
=========================

:AUTHOR: DAVID S. MILLER <DAVEM@REDHAT.COM>
:AUTHOR: RICHARD HENDERSON <RTH@CYGNUS.COM>
:AUTHOR: JAKUB JELINEK <JAKUB@REDHAT.COM>

THIS IS A GUIDE TO DEVICE DRIVER WRITERS ON HOW TO USE THE DMA API
WITH EXAMPLE PSEUDO-CODE.  FOR A CONCISE DESCRIPTION OF THE API, SEE
DMA-API.TXT.

CPU AND DMA ADDRESSES
=====================

THERE ARE SEVERAL KINDS OF ADDRESSES INVOLVED IN THE DMA API, AND IT'S
IMPORTANT TO UNDERSTAND THE DIFFERENCES.

THE KERNEL NORMALLY USES VIRTUAL ADDRESSES.  ANY ADDRESS RETURNED BY
KMALLOC(), VMALLOC(), AND SIMILAR INTERFACES IS A VIRTUAL ADDRESS AND CAN
BE STORED IN A ``VOID *``.

THE VIRTUAL MEMORY SYSTEM (TLB, PAGE TABLES, ETC.) TRANSLATES VIRTUAL
ADDRESSES TO CPU PHYSICAL ADDRESSES, WHICH ARE STORED AS "PHYS_ADDR_T" OR
"RESOURCE_SIZE_T".  THE KERNEL MANAGES DEVICE RESOURCES LIKE REGISTERS AS
PHYSICAL ADDRESSES.  THESE ARE THE ADDRESSES IN /PROC/IOMEM.  THE PHYSICAL
ADDRESS IS NOT DIRECTLY USEFUL TO A DRIVER; IT MUST USE IOREMAP() TO MAP
THE SPACE AND PRODUCE A VIRTUAL ADDRESS.

I/O DEVICES USE A THIRD KIND OF ADDRESS: A "BUS ADDRESS".  IF A DEVICE HAS
REGISTERS AT AN MMIO ADDRESS, OR IF IT PERFORMS DMA TO READ OR WRITE SYSTEM
MEMORY, THE ADDRESSES USED BY THE DEVICE ARE BUS ADDRESSES.  IN SOME
SYSTEMS, BUS ADDRESSES ARE IDENTICAL TO CPU PHYSICAL ADDRESSES, BUT IN
GENERAL THEY ARE NOT.  IOMMUS AND HOST BRIDGES CAN PRODUCE ARBITRARY
MAPPINGS BETWEEN PHYSICAL AND BUS ADDRESSES.

FROM A DEVICE'S POINT OF VIEW, DMA USES THE BUS ADDRESS SPACE, BUT IT MAY
BE RESTRICTED TO A SUBSET OF THAT SPACE.  FOR EXAMPLE, EVEN IF A SYSTEM
SUPPORTS 64-BIT ADDRESSES FOR MAIN MEMORY AND PCI BARS, IT MAY USE AN IOMMU
SO DEVICES ONLY NEED TO USE 32-BIT DMA ADDRESSES.

HERE'S A PICTURE AND SOME EXAMPLES::

               CPU                  CPU                  BUS
             VIRTUAL              PHYSICAL             ADDRESS
             ADDRESS              ADDRESS               SPACE
              SPACE                SPACE

            +-------+             +------+             +------+
            |       |             |MMIO  |   OFFSET    |      |
            |       |  VIRTUAL    |SPACE |   APPLIED   |      |
          C +-------+ --------> B +------+ ----------> +------+ A
            |       |  MAPPING    |      |   BY HOST   |      |
  +-----+   |       |             |      |   BRIDGE    |      |   +--------+
  |     |   |       |             +------+             |      |   |        |
  | CPU |   |       |             | RAM  |             |      |   | DEVICE |
  |     |   |       |             |      |             |      |   |        |
  +-----+   +-------+             +------+             +------+   +--------+
            |       |  VIRTUAL    |BUFFER|   MAPPING   |      |
          X +-------+ --------> Y +------+ <---------- +------+ Z
            |       |  MAPPING    | RAM  |   BY IOMMU
            |       |             |      |
            |       |             |      |
            +-------+             +------+

DURING THE ENUMERATION PROCESS, THE KERNEL LEARNS ABOUT I/O DEVICES AND
THEIR MMIO SPACE AND THE HOST BRIDGES THAT CONNECT THEM TO THE SYSTEM.  FOR
EXAMPLE, IF A PCI DEVICE HAS A BAR, THE KERNEL READS THE BUS ADDRESS (A)
FROM THE BAR AND CONVERTS IT TO A CPU PHYSICAL ADDRESS (B).  THE ADDRESS B
IS STORED IN A STRUCT RESOURCE AND USUALLY EXPOSED VIA /PROC/IOMEM.  WHEN A
DRIVER CLAIMS A DEVICE, IT TYPICALLY USES IOREMAP() TO MAP PHYSICAL ADDRESS
B AT A VIRTUAL ADDRESS (C).  IT CAN THEN USE, E.G., IOREAD32(C), TO ACCESS
THE DEVICE REGISTERS AT BUS ADDRESS A.

IF THE DEVICE SUPPORTS DMA, THE DRIVER SETS UP A BUFFER USING KMALLOC() OR
A SIMILAR INTERFACE, WHICH RETURNS A VIRTUAL ADDRESS (X).  THE VIRTUAL
MEMORY SYSTEM MAPS X TO A PHYSICAL ADDRESS (Y) IN SYSTEM RAM.  THE DRIVER
CAN USE VIRTUAL ADDRESS X TO ACCESS THE BUFFER, BUT THE DEVICE ITSELF
CANNOT BECAUSE DMA DOESN'T GO THROUGH THE CPU VIRTUAL MEMORY SYSTEM.

IN SOME SIMPLE SYSTEMS, THE DEVICE CAN DO DMA DIRECTLY TO PHYSICAL ADDRESS
Y.  BUT IN MANY OTHERS, THERE IS IOMMU HARDWARE THAT TRANSLATES DMA
ADDRESSES TO PHYSICAL ADDRESSES, E.G., IT TRANSLATES Z TO Y.  THIS IS PART
OF THE REASON FOR THE DMA API: THE DRIVER CAN GIVE A VIRTUAL ADDRESS X TO
AN INTERFACE LIKE DMA_MAP_SINGLE(), WHICH SETS UP ANY REQUIRED IOMMU
MAPPING AND RETURNS THE DMA ADDRESS Z.  THE DRIVER THEN TELLS THE DEVICE TO
DO DMA TO Z, AND THE IOMMU MAPS IT TO THE BUFFER AT ADDRESS Y IN SYSTEM
RAM.

SO THAT LINUX CAN USE THE DYNAMIC DMA MAPPING, IT NEEDS SOME HELP FROM THE
DRIVERS, NAMELY IT HAS TO TAKE INTO ACCOUNT THAT DMA ADDRESSES SHOULD BE
MAPPED ONLY FOR THE TIME THEY ARE ACTUALLY USED AND UNMAPPED AFTER THE DMA
TRANSFER.

THE FOLLOWING API WILL WORK OF COURSE EVEN ON PLATFORMS WHERE NO SUCH
HARDWARE EXISTS.

NOTE THAT THE DMA API WORKS WITH ANY BUS INDEPENDENT OF THE UNDERLYING
MICROPROCESSOR ARCHITECTURE. YOU SHOULD USE THE DMA API RATHER THAN THE
BUS-SPECIFIC DMA API, I.E., USE THE DMA_MAP_*() INTERFACES RATHER THAN THE
PCI_MAP_*() INTERFACES.

FIRST OF ALL, YOU SHOULD MAKE SURE::

	#INCLUDE <LINUX/DMA-MAPPING.H>

IS IN YOUR DRIVER, WHICH PROVIDES THE DEFINITION OF DMA_ADDR_T.  THIS TYPE
CAN HOLD ANY VALID DMA ADDRESS FOR THE PLATFORM AND SHOULD BE USED
EVERYWHERE YOU HOLD A DMA ADDRESS RETURNED FROM THE DMA MAPPING FUNCTIONS.

WHAT MEMORY IS DMA'ABLE?
========================

THE FIRST PIECE OF INFORMATION YOU MUST KNOW IS WHAT KERNEL MEMORY CAN
BE USED WITH THE DMA MAPPING FACILITIES.  THERE HAS BEEN AN UNWRITTEN
SET OF RULES REGARDING THIS, AND THIS TEXT IS AN ATTEMPT TO FINALLY
WRITE THEM DOWN.

IF YOU ACQUIRED YOUR MEMORY VIA THE PAGE ALLOCATOR
(I.E. __GET_FREE_PAGE*()) OR THE GENERIC MEMORY ALLOCATORS
(I.E. KMALLOC() OR KMEM_CACHE_ALLOC()) THEN YOU MAY DMA TO/FROM
THAT MEMORY USING THE ADDRESSES RETURNED FROM THOSE ROUTINES.

THIS MEANS SPECIFICALLY THAT YOU MAY _NOT_ USE THE MEMORY/ADDRESSES
RETURNED FROM VMALLOC() FOR DMA.  IT IS POSSIBLE TO DMA TO THE
_UNDERLYING_ MEMORY MAPPED INTO A VMALLOC() AREA, BUT THIS REQUIRES
WALKING PAGE TABLES TO GET THE PHYSICAL ADDRESSES, AND THEN
TRANSLATING EACH OF THOSE PAGES BACK TO A KERNEL ADDRESS USING
SOMETHING LIKE __VA().  [ EDIT: UPDATE THIS WHEN WE INTEGRATE
GERD KNORR'S GENERIC CODE WHICH DOES THIS. ]

THIS RULE ALSO MEANS THAT YOU MAY USE NEITHER KERNEL IMAGE ADDRESSES
(ITEMS IN DATA/TEXT/BSS SEGMENTS), NOR MODULE IMAGE ADDRESSES, NOR
STACK ADDRESSES FOR DMA.  THESE COULD ALL BE MAPPED SOMEWHERE ENTIRELY
DIFFERENT THAN THE REST OF PHYSICAL MEMORY.  EVEN IF THOSE CLASSES OF
MEMORY COULD PHYSICALLY WORK WITH DMA, YOU'D NEED TO ENSURE THE I/O
BUFFERS WERE CACHELINE-ALIGNED.  WITHOUT THAT, YOU'D SEE CACHELINE
SHARING PROBLEMS (DATA CORRUPTION) ON CPUS WITH DMA-INCOHERENT CACHES.
(THE CPU COULD WRITE TO ONE WORD, DMA WOULD WRITE TO A DIFFERENT ONE
IN THE SAME CACHE LINE, AND ONE OF THEM COULD BE OVERWRITTEN.)

ALSO, THIS MEANS THAT YOU CANNOT TAKE THE RETURN OF A KMAP()
CALL AND DMA TO/FROM THAT.  THIS IS SIMILAR TO VMALLOC().

WHAT ABOUT BLOCK I/O AND NETWORKING BUFFERS?  THE BLOCK I/O AND
NETWORKING SUBSYSTEMS MAKE SURE THAT THE BUFFERS THEY USE ARE VALID
FOR YOU TO DMA FROM/TO.

DMA ADDRESSING CAPABILITIES
===========================

BY DEFAULT, THE KERNEL ASSUMES THAT YOUR DEVICE CAN ADDRESS 32-BITS OF DMA
ADDRESSING.  FOR A 64-BIT CAPABLE DEVICE, THIS NEEDS TO BE INCREASED, AND FOR
A DEVICE WITH LIMITATIONS, IT NEEDS TO BE DECREASED.

SPECIAL NOTE ABOUT PCI: PCI-X SPECIFICATION REQUIRES PCI-X DEVICES TO SUPPORT
64-BIT ADDRESSING (DAC) FOR ALL TRANSACTIONS.  AND AT LEAST ONE PLATFORM (SGI
SN2) REQUIRES 64-BIT CONSISTENT ALLOCATIONS TO OPERATE CORRECTLY WHEN THE IO
BUS IS IN PCI-X MODE.

FOR CORRECT OPERATION, YOU MUST SET THE DMA MASK TO INFORM THE KERNEL ABOUT
YOUR DEVICES DMA ADDRESSING CAPABILITIES.

THIS IS PERFORMED VIA A CALL TO DMA_SET_MASK_AND_COHERENT()::

	INT DMA_SET_MASK_AND_COHERENT(STRUCT DEVICE *DEV, U64 MASK);

WHICH WILL SET THE MASK FOR BOTH STREAMING AND COHERENT APIS TOGETHER.  IF YOU
HAVE SOME SPECIAL REQUIREMENTS, THEN THE FOLLOWING TWO SEPARATE CALLS CAN BE
USED INSTEAD:

	THE SETUP FOR STREAMING MAPPINGS IS PERFORMED VIA A CALL TO
	DMA_SET_MASK()::

		INT DMA_SET_MASK(STRUCT DEVICE *DEV, U64 MASK);

	THE SETUP FOR CONSISTENT ALLOCATIONS IS PERFORMED VIA A CALL
	TO DMA_SET_COHERENT_MASK()::

		INT DMA_SET_COHERENT_MASK(STRUCT DEVICE *DEV, U64 MASK);

HERE, DEV IS A POINTER TO THE DEVICE STRUCT OF YOUR DEVICE, AND MASK IS A BIT
MASK DESCRIBING WHICH BITS OF AN ADDRESS YOUR DEVICE SUPPORTS.  OFTEN THE
DEVICE STRUCT OF YOUR DEVICE IS EMBEDDED IN THE BUS-SPECIFIC DEVICE STRUCT OF
YOUR DEVICE.  FOR EXAMPLE, &PDEV->DEV IS A POINTER TO THE DEVICE STRUCT OF A
PCI DEVICE (PDEV IS A POINTER TO THE PCI DEVICE STRUCT OF YOUR DEVICE).

THESE CALLS USUALLY RETURN ZERO TO INDICATED YOUR DEVICE CAN PERFORM DMA
PROPERLY ON THE MACHINE GIVEN THE ADDRESS MASK YOU PROVIDED, BUT THEY MIGHT
RETURN AN ERROR IF THE MASK IS TOO SMALL TO BE SUPPORTABLE ON THE GIVEN
SYSTEM.  IF IT RETURNS NON-ZERO, YOUR DEVICE CANNOT PERFORM DMA PROPERLY ON
THIS PLATFORM, AND ATTEMPTING TO DO SO WILL RESULT IN UNDEFINED BEHAVIOR.
YOU MUST NOT USE DMA ON THIS DEVICE UNLESS THE DMA_SET_MASK FAMILY OF
FUNCTIONS HAS RETURNED SUCCESS.

THIS MEANS THAT IN THE FAILURE CASE, YOU HAVE TWO OPTIONS:

1) USE SOME NON-DMA MODE FOR DATA TRANSFER, IF POSSIBLE.
2) IGNORE THIS DEVICE AND DO NOT INITIALIZE IT.

IT IS RECOMMENDED THAT YOUR DRIVER PRINT A KERNEL KERN_WARNING MESSAGE WHEN
SETTING THE DMA MASK FAILS.  IN THIS MANNER, IF A USER OF YOUR DRIVER REPORTS
THAT PERFORMANCE IS BAD OR THAT THE DEVICE IS NOT EVEN DETECTED, YOU CAN ASK
THEM FOR THE KERNEL MESSAGES TO FIND OUT EXACTLY WHY.

THE STANDARD 64-BIT ADDRESSING DEVICE WOULD DO SOMETHING LIKE THIS::

	IF (DMA_SET_MASK_AND_COHERENT(DEV, DMA_BIT_MASK(64))) {
		DEV_WARN(DEV, "MYDEV: NO SUITABLE DMA AVAILABLE\N");
		GOTO IGNORE_THIS_DEVICE;
	}

IF THE DEVICE ONLY SUPPORTS 32-BIT ADDRESSING FOR DESCRIPTORS IN THE
COHERENT ALLOCATIONS, BUT SUPPORTS FULL 64-BITS FOR STREAMING MAPPINGS
IT WOULD LOOK LIKE THIS::

	IF (DMA_SET_MASK(DEV, DMA_BIT_MASK(64))) {
		DEV_WARN(DEV, "MYDEV: NO SUITABLE DMA AVAILABLE\N");
		GOTO IGNORE_THIS_DEVICE;
	}

THE COHERENT MASK WILL ALWAYS BE ABLE TO SET THE SAME OR A SMALLER MASK AS
THE STREAMING MASK. HOWEVER FOR THE RARE CASE THAT A DEVICE DRIVER ONLY
USES CONSISTENT ALLOCATIONS, ONE WOULD HAVE TO CHECK THE RETURN VALUE FROM
DMA_SET_COHERENT_MASK().

FINALLY, IF YOUR DEVICE CAN ONLY DRIVE THE LOW 24-BITS OF
ADDRESS YOU MIGHT DO SOMETHING LIKE::

	IF (DMA_SET_MASK(DEV, DMA_BIT_MASK(24))) {
		DEV_WARN(DEV, "MYDEV: 24-BIT DMA ADDRESSING NOT AVAILABLE\N");
		GOTO IGNORE_THIS_DEVICE;
	}

WHEN DMA_SET_MASK() OR DMA_SET_MASK_AND_COHERENT() IS SUCCESSFUL, AND
RETURNS ZERO, THE KERNEL SAVES AWAY THIS MASK YOU HAVE PROVIDED.  THE
KERNEL WILL USE THIS INFORMATION LATER WHEN YOU MAKE DMA MAPPINGS.

THERE IS A CASE WHICH WE ARE AWARE OF AT THIS TIME, WHICH IS WORTH
MENTIONING IN THIS DOCUMENTATION.  IF YOUR DEVICE SUPPORTS MULTIPLE
FUNCTIONS (FOR EXAMPLE A SOUND CARD PROVIDES PLAYBACK AND RECORD
FUNCTIONS) AND THE VARIOUS DIFFERENT FUNCTIONS HAVE _DIFFERENT_
DMA ADDRESSING LIMITATIONS, YOU MAY WISH TO PROBE EACH MASK AND
ONLY PROVIDE THE FUNCTIONALITY WHICH THE MACHINE CAN HANDLE.  IT
IS IMPORTANT THAT THE LAST CALL TO DMA_SET_MASK() BE FOR THE
MOST SPECIFIC MASK.

HERE IS PSEUDO-CODE SHOWING HOW THIS MIGHT BE DONE::

	#DEFINE PLAYBACK_ADDRESS_BITS	DMA_BIT_MASK(32)
	#DEFINE RECORD_ADDRESS_BITS	DMA_BIT_MASK(24)

	STRUCT MY_SOUND_CARD *CARD;
	STRUCT DEVICE *DEV;

	...
	IF (!DMA_SET_MASK(DEV, PLAYBACK_ADDRESS_BITS)) {
		CARD->PLAYBACK_ENABLED = 1;
	} ELSE {
		CARD->PLAYBACK_ENABLED = 0;
		DEV_WARN(DEV, "%S: PLAYBACK DISABLED DUE TO DMA LIMITATIONS\N",
		       CARD->NAME);
	}
	IF (!DMA_SET_MASK(DEV, RECORD_ADDRESS_BITS)) {
		CARD->RECORD_ENABLED = 1;
	} ELSE {
		CARD->RECORD_ENABLED = 0;
		DEV_WARN(DEV, "%S: RECORD DISABLED DUE TO DMA LIMITATIONS\N",
		       CARD->NAME);
	}

A SOUND CARD WAS USED AS AN EXAMPLE HERE BECAUSE THIS GENRE OF PCI
DEVICES SEEMS TO BE LITTERED WITH ISA CHIPS GIVEN A PCI FRONT END,
AND THUS RETAINING THE 16MB DMA ADDRESSING LIMITATIONS OF ISA.

TYPES OF DMA MAPPINGS
=====================

THERE ARE TWO TYPES OF DMA MAPPINGS:

- CONSISTENT DMA MAPPINGS WHICH ARE USUALLY MAPPED AT DRIVER
  INITIALIZATION, UNMAPPED AT THE END AND FOR WHICH THE HARDWARE SHOULD
  GUARANTEE THAT THE DEVICE AND THE CPU CAN ACCESS THE DATA
  IN PARALLEL AND WILL SEE UPDATES MADE BY EACH OTHER WITHOUT ANY
  EXPLICIT SOFTWARE FLUSHING.

  THINK OF "CONSISTENT" AS "SYNCHRONOUS" OR "COHERENT".

  THE CURRENT DEFAULT IS TO RETURN CONSISTENT MEMORY IN THE LOW 32
  BITS OF THE DMA SPACE.  HOWEVER, FOR FUTURE COMPATIBILITY YOU SHOULD
  SET THE CONSISTENT MASK EVEN IF THIS DEFAULT IS FINE FOR YOUR
  DRIVER.

  GOOD EXAMPLES OF WHAT TO USE CONSISTENT MAPPINGS FOR ARE:

	- NETWORK CARD DMA RING DESCRIPTORS.
	- SCSI ADAPTER MAILBOX COMMAND DATA STRUCTURES.
	- DEVICE FIRMWARE MICROCODE EXECUTED OUT OF
	  MAIN MEMORY.

  THE INVARIANT THESE EXAMPLES ALL REQUIRE IS THAT ANY CPU STORE
  TO MEMORY IS IMMEDIATELY VISIBLE TO THE DEVICE, AND VICE
  VERSA.  CONSISTENT MAPPINGS GUARANTEE THIS.

  .. IMPORTANT::

	     CONSISTENT DMA MEMORY DOES NOT PRECLUDE THE USAGE OF
	     PROPER MEMORY BARRIERS.  THE CPU MAY REORDER STORES TO
	     CONSISTENT MEMORY JUST AS IT MAY NORMAL MEMORY.  EXAMPLE:
	     IF IT IS IMPORTANT FOR THE DEVICE TO SEE THE FIRST WORD
	     OF A DESCRIPTOR UPDATED BEFORE THE SECOND, YOU MUST DO
	     SOMETHING LIKE::

		DESC->WORD0 = ADDRESS;
		WMB();
		DESC->WORD1 = DESC_VALID;

             IN ORDER TO GET CORRECT BEHAVIOR ON ALL PLATFORMS.

	     ALSO, ON SOME PLATFORMS YOUR DRIVER MAY NEED TO FLUSH CPU WRITE
	     BUFFERS IN MUCH THE SAME WAY AS IT NEEDS TO FLUSH WRITE BUFFERS
	     FOUND IN PCI BRIDGES (SUCH AS BY READING A REGISTER'S VALUE
	     AFTER WRITING IT).

- STREAMING DMA MAPPINGS WHICH ARE USUALLY MAPPED FOR ONE DMA
  TRANSFER, UNMAPPED RIGHT AFTER IT (UNLESS YOU USE DMA_SYNC_* BELOW)
  AND FOR WHICH HARDWARE CAN OPTIMIZE FOR SEQUENTIAL ACCESSES.

  THINK OF "STREAMING" AS "ASYNCHRONOUS" OR "OUTSIDE THE COHERENCY
  DOMAIN".

  GOOD EXAMPLES OF WHAT TO USE STREAMING MAPPINGS FOR ARE:

	- NETWORKING BUFFERS TRANSMITTED/RECEIVED BY A DEVICE.
	- FILESYSTEM BUFFERS WRITTEN/READ BY A SCSI DEVICE.

  THE INTERFACES FOR USING THIS TYPE OF MAPPING WERE DESIGNED IN
  SUCH A WAY THAT AN IMPLEMENTATION CAN MAKE WHATEVER PERFORMANCE
  OPTIMIZATIONS THE HARDWARE ALLOWS.  TO THIS END, WHEN USING
  SUCH MAPPINGS YOU MUST BE EXPLICIT ABOUT WHAT YOU WANT TO HAPPEN.

NEITHER TYPE OF DMA MAPPING HAS ALIGNMENT RESTRICTIONS THAT COME FROM
THE UNDERLYING BUS, ALTHOUGH SOME DEVICES MAY HAVE SUCH RESTRICTIONS.
ALSO, SYSTEMS WITH CACHES THAT AREN'T DMA-COHERENT WILL WORK BETTER
WHEN THE UNDERLYING BUFFERS DON'T SHARE CACHE LINES WITH OTHER DATA.


USING CONSISTENT DMA MAPPINGS
=============================

TO ALLOCATE AND MAP LARGE (PAGE_SIZE OR SO) CONSISTENT DMA REGIONS,
YOU SHOULD DO::

	DMA_ADDR_T DMA_HANDLE;

	CPU_ADDR = DMA_ALLOC_COHERENT(DEV, SIZE, &DMA_HANDLE, GFP);

WHERE DEVICE IS A ``STRUCT DEVICE *``. THIS MAY BE CALLED IN INTERRUPT
CONTEXT WITH THE GFP_ATOMIC FLAG.

SIZE IS THE LENGTH OF THE REGION YOU WANT TO ALLOCATE, IN BYTES.

THIS ROUTINE WILL ALLOCATE RAM FOR THAT REGION, SO IT ACTS SIMILARLY TO
__GET_FREE_PAGES() (BUT TAKES SIZE INSTEAD OF A PAGE ORDER).  IF YOUR
DRIVER NEEDS REGIONS SIZED SMALLER THAN A PAGE, YOU MAY PREFER USING
THE DMA_POOL INTERFACE, DESCRIBED BELOW.

THE CONSISTENT DMA MAPPING INTERFACES, WILL BY DEFAULT RETURN A DMA ADDRESS
WHICH IS 32-BIT ADDRESSABLE.  EVEN IF THE DEVICE INDICATES (VIA THE DMA MASK)
THAT IT MAY ADDRESS THE UPPER 32-BITS, CONSISTENT ALLOCATION WILL ONLY
RETURN > 32-BIT ADDRESSES FOR DMA IF THE CONSISTENT DMA MASK HAS BEEN
EXPLICITLY CHANGED VIA DMA_SET_COHERENT_MASK().  THIS IS TRUE OF THE
DMA_POOL INTERFACE AS WELL.

DMA_ALLOC_COHERENT() RETURNS TWO VALUES: THE VIRTUAL ADDRESS WHICH YOU
CAN USE TO ACCESS IT FROM THE CPU AND DMA_HANDLE WHICH YOU PASS TO THE
CARD.

THE CPU VIRTUAL ADDRESS AND THE DMA ADDRESS ARE BOTH
GUARANTEED TO BE ALIGNED TO THE SMALLEST PAGE_SIZE ORDER WHICH
IS GREATER THAN OR EQUAL TO THE REQUESTED SIZE.  THIS INVARIANT
EXISTS (FOR EXAMPLE) TO GUARANTEE THAT IF YOU ALLOCATE A CHUNK
WHICH IS SMALLER THAN OR EQUAL TO 64 KILOBYTES, THE EXTENT OF THE
BUFFER YOU RECEIVE WILL NOT CROSS A 64K BOUNDARY.

TO UNMAP AND FREE SUCH A DMA REGION, YOU CALL::

	DMA_FREE_COHERENT(DEV, SIZE, CPU_ADDR, DMA_HANDLE);

WHERE DEV, SIZE ARE THE SAME AS IN THE ABOVE CALL AND CPU_ADDR AND
DMA_HANDLE ARE THE VALUES DMA_ALLOC_COHERENT() RETURNED TO YOU.
THIS FUNCTION MAY NOT BE CALLED IN INTERRUPT CONTEXT.

IF YOUR DRIVER NEEDS LOTS OF SMALLER MEMORY REGIONS, YOU CAN WRITE
CUSTOM CODE TO SUBDIVIDE PAGES RETURNED BY DMA_ALLOC_COHERENT(),
OR YOU CAN USE THE DMA_POOL API TO DO THAT.  A DMA_POOL IS LIKE
A KMEM_CACHE, BUT IT USES DMA_ALLOC_COHERENT(), NOT __GET_FREE_PAGES().
ALSO, IT UNDERSTANDS COMMON HARDWARE CONSTRAINTS FOR ALIGNMENT,
LIKE QUEUE HEADS NEEDING TO BE ALIGNED ON N BYTE BOUNDARIES.

CREATE A DMA_POOL LIKE THIS::

	STRUCT DMA_POOL *POOL;

	POOL = DMA_POOL_CREATE(NAME, DEV, SIZE, ALIGN, BOUNDARY);

THE "NAME" IS FOR DIAGNOSTICS (LIKE A KMEM_CACHE NAME); DEV AND SIZE
ARE AS ABOVE.  THE DEVICE'S HARDWARE ALIGNMENT REQUIREMENT FOR THIS
TYPE OF DATA IS "ALIGN" (WHICH IS EXPRESSED IN BYTES, AND MUST BE A
POWER OF TWO).  IF YOUR DEVICE HAS NO BOUNDARY CROSSING RESTRICTIONS,
PASS 0 FOR BOUNDARY; PASSING 4096 SAYS MEMORY ALLOCATED FROM THIS POOL
MUST NOT CROSS 4KBYTE BOUNDARIES (BUT AT THAT TIME IT MAY BE BETTER TO
USE DMA_ALLOC_COHERENT() DIRECTLY INSTEAD).

ALLOCATE MEMORY FROM A DMA POOL LIKE THIS::

	CPU_ADDR = DMA_POOL_ALLOC(POOL, FLAGS, &DMA_HANDLE);

FLAGS ARE GFP_KERNEL IF BLOCKING IS PERMITTED (NOT IN_INTERRUPT NOR
HOLDING SMP LOCKS), GFP_ATOMIC OTHERWISE.  LIKE DMA_ALLOC_COHERENT(),
THIS RETURNS TWO VALUES, CPU_ADDR AND DMA_HANDLE.

FREE MEMORY THAT WAS ALLOCATED FROM A DMA_POOL LIKE THIS::

	DMA_POOL_FREE(POOL, CPU_ADDR, DMA_HANDLE);

WHERE POOL IS WHAT YOU PASSED TO DMA_POOL_ALLOC(), AND CPU_ADDR AND
DMA_HANDLE ARE THE VALUES DMA_POOL_ALLOC() RETURNED. THIS FUNCTION
MAY BE CALLED IN INTERRUPT CONTEXT.

DESTROY A DMA_POOL BY CALLING::

	DMA_POOL_DESTROY(POOL);

MAKE SURE YOU'VE CALLED DMA_POOL_FREE() FOR ALL MEMORY ALLOCATED
FROM A POOL BEFORE YOU DESTROY THE POOL. THIS FUNCTION MAY NOT
BE CALLED IN INTERRUPT CONTEXT.

DMA DIRECTION
=============

THE INTERFACES DESCRIBED IN SUBSEQUENT PORTIONS OF THIS DOCUMENT
TAKE A DMA DIRECTION ARGUMENT, WHICH IS AN INTEGER AND TAKES ON
ONE OF THE FOLLOWING VALUES::

 DMA_BIDIRECTIONAL
 DMA_TO_DEVICE
 DMA_FROM_DEVICE
 DMA_NONE

YOU SHOULD PROVIDE THE EXACT DMA DIRECTION IF YOU KNOW IT.

DMA_TO_DEVICE MEANS "FROM MAIN MEMORY TO THE DEVICE"
DMA_FROM_DEVICE MEANS "FROM THE DEVICE TO MAIN MEMORY"
IT IS THE DIRECTION IN WHICH THE DATA MOVES DURING THE DMA
TRANSFER.

YOU ARE _STRONGLY_ ENCOURAGED TO SPECIFY THIS AS PRECISELY
AS YOU POSSIBLY CAN.

IF YOU ABSOLUTELY CANNOT KNOW THE DIRECTION OF THE DMA TRANSFER,
SPECIFY DMA_BIDIRECTIONAL.  IT MEANS THAT THE DMA CAN GO IN
EITHER DIRECTION.  THE PLATFORM GUARANTEES THAT YOU MAY LEGALLY
SPECIFY THIS, AND THAT IT WILL WORK, BUT THIS MAY BE AT THE
COST OF PERFORMANCE FOR EXAMPLE.

THE VALUE DMA_NONE IS TO BE USED FOR DEBUGGING.  ONE CAN
HOLD THIS IN A DATA STRUCTURE BEFORE YOU COME TO KNOW THE
PRECISE DIRECTION, AND THIS WILL HELP CATCH CASES WHERE YOUR
DIRECTION TRACKING LOGIC HAS FAILED TO SET THINGS UP PROPERLY.

ANOTHER ADVANTAGE OF SPECIFYING THIS VALUE PRECISELY (OUTSIDE OF
POTENTIAL PLATFORM-SPECIFIC OPTIMIZATIONS OF SUCH) IS FOR DEBUGGING.
SOME PLATFORMS ACTUALLY HAVE A WRITE PERMISSION BOOLEAN WHICH DMA
MAPPINGS CAN BE MARKED WITH, MUCH LIKE PAGE PROTECTIONS IN THE USER
PROGRAM ADDRESS SPACE.  SUCH PLATFORMS CAN AND DO REPORT ERRORS IN THE
KERNEL LOGS WHEN THE DMA CONTROLLER HARDWARE DETECTS VIOLATION OF THE
PERMISSION SETTING.

ONLY STREAMING MAPPINGS SPECIFY A DIRECTION, CONSISTENT MAPPINGS
IMPLICITLY HAVE A DIRECTION ATTRIBUTE SETTING OF
DMA_BIDIRECTIONAL.

THE SCSI SUBSYSTEM TELLS YOU THE DIRECTION TO USE IN THE
'SC_DATA_DIRECTION' MEMBER OF THE SCSI COMMAND YOUR DRIVER IS
WORKING ON.

FOR NETWORKING DRIVERS, IT'S A RATHER SIMPLE AFFAIR.  FOR TRANSMIT
PACKETS, MAP/UNMAP THEM WITH THE DMA_TO_DEVICE DIRECTION
SPECIFIER.  FOR RECEIVE PACKETS, JUST THE OPPOSITE, MAP/UNMAP THEM
WITH THE DMA_FROM_DEVICE DIRECTION SPECIFIER.

USING STREAMING DMA MAPPINGS
============================

THE STREAMING DMA MAPPING ROUTINES CAN BE CALLED FROM INTERRUPT
CONTEXT.  THERE ARE TWO VERSIONS OF EACH MAP/UNMAP, ONE WHICH WILL
MAP/UNMAP A SINGLE MEMORY REGION, AND ONE WHICH WILL MAP/UNMAP A
SCATTERLIST.

TO MAP A SINGLE REGION, YOU DO::

	STRUCT DEVICE *DEV = &MY_DEV->DEV;
	DMA_ADDR_T DMA_HANDLE;
	VOID *ADDR = BUFFER->PTR;
	SIZE_T SIZE = BUFFER->LEN;

	DMA_HANDLE = DMA_MAP_SINGLE(DEV, ADDR, SIZE, DIRECTION);
	IF (DMA_MAPPING_ERROR(DEV, DMA_HANDLE)) {
		/*
		 * REDUCE CURRENT DMA MAPPING USAGE,
		 * DELAY AND TRY AGAIN LATER OR
		 * RESET DRIVER.
		 */
		GOTO MAP_ERROR_HANDLING;
	}

AND TO UNMAP IT::

	DMA_UNMAP_SINGLE(DEV, DMA_HANDLE, SIZE, DIRECTION);

YOU SHOULD CALL DMA_MAPPING_ERROR() AS DMA_MAP_SINGLE() COULD FAIL AND RETURN
ERROR.  DOING SO WILL ENSURE THAT THE MAPPING CODE WILL WORK CORRECTLY ON ALL
DMA IMPLEMENTATIONS WITHOUT ANY DEPENDENCY ON THE SPECIFICS OF THE UNDERLYING
IMPLEMENTATION. USING THE RETURNED ADDRESS WITHOUT CHECKING FOR ERRORS COULD
RESULT IN FAILURES RANGING FROM PANICS TO SILENT DATA CORRUPTION.  THE SAME
APPLIES TO DMA_MAP_PAGE() AS WELL.

YOU SHOULD CALL DMA_UNMAP_SINGLE() WHEN THE DMA ACTIVITY IS FINISHED, E.G.,
FROM THE INTERRUPT WHICH TOLD YOU THAT THE DMA TRANSFER IS DONE.

USING CPU POINTERS LIKE THIS FOR SINGLE MAPPINGS HAS A DISADVANTAGE:
YOU CANNOT REFERENCE HIGHMEM MEMORY IN THIS WAY.  THUS, THERE IS A
MAP/UNMAP INTERFACE PAIR AKIN TO DMA_{MAP,UNMAP}_SINGLE().  THESE
INTERFACES DEAL WITH PAGE/OFFSET PAIRS INSTEAD OF CPU POINTERS.
SPECIFICALLY::

	STRUCT DEVICE *DEV = &MY_DEV->DEV;
	DMA_ADDR_T DMA_HANDLE;
	STRUCT PAGE *PAGE = BUFFER->PAGE;
	UNSIGNED LONG OFFSET = BUFFER->OFFSET;
	SIZE_T SIZE = BUFFER->LEN;

	DMA_HANDLE = DMA_MAP_PAGE(DEV, PAGE, OFFSET, SIZE, DIRECTION);
	IF (DMA_MAPPING_ERROR(DEV, DMA_HANDLE)) {
		/*
		 * REDUCE CURRENT DMA MAPPING USAGE,
		 * DELAY AND TRY AGAIN LATER OR
		 * RESET DRIVER.
		 */
		GOTO MAP_ERROR_HANDLING;
	}

	...

	DMA_UNMAP_PAGE(DEV, DMA_HANDLE, SIZE, DIRECTION);

HERE, "OFFSET" MEANS BYTE OFFSET WITHIN THE GIVEN PAGE.

YOU SHOULD CALL DMA_MAPPING_ERROR() AS DMA_MAP_PAGE() COULD FAIL AND RETURN
ERROR AS OUTLINED UNDER THE DMA_MAP_SINGLE() DISCUSSION.

YOU SHOULD CALL DMA_UNMAP_PAGE() WHEN THE DMA ACTIVITY IS FINISHED, E.G.,
FROM THE INTERRUPT WHICH TOLD YOU THAT THE DMA TRANSFER IS DONE.

WITH SCATTERLISTS, YOU MAP A REGION GATHERED FROM SEVERAL REGIONS BY::

	INT I, COUNT = DMA_MAP_SG(DEV, SGLIST, NENTS, DIRECTION);
	STRUCT SCATTERLIST *SG;

	FOR_EACH_SG(SGLIST, SG, COUNT, I) {
		HW_ADDRESS[I] = SG_DMA_ADDRESS(SG);
		HW_LEN[I] = SG_DMA_LEN(SG);
	}

WHERE NENTS IS THE NUMBER OF ENTRIES IN THE SGLIST.

THE IMPLEMENTATION IS FREE TO MERGE SEVERAL CONSECUTIVE SGLIST ENTRIES
INTO ONE (E.G. IF DMA MAPPING IS DONE WITH PAGE_SIZE GRANULARITY, ANY
CONSECUTIVE SGLIST ENTRIES CAN BE MERGED INTO ONE PROVIDED THE FIRST ONE
ENDS AND THE SECOND ONE STARTS ON A PAGE BOUNDARY - IN FACT THIS IS A HUGE
ADVANTAGE FOR CARDS WHICH EITHER CANNOT DO SCATTER-GATHER OR HAVE VERY
LIMITED NUMBER OF SCATTER-GATHER ENTRIES) AND RETURNS THE ACTUAL NUMBER
OF SG ENTRIES IT MAPPED THEM TO. ON FAILURE 0 IS RETURNED.

THEN YOU SHOULD LOOP COUNT TIMES (NOTE: THIS CAN BE LESS THAN NENTS TIMES)
AND USE SG_DMA_ADDRESS() AND SG_DMA_LEN() MACROS WHERE YOU PREVIOUSLY
ACCESSED SG->ADDRESS AND SG->LENGTH AS SHOWN ABOVE.

TO UNMAP A SCATTERLIST, JUST CALL::

	DMA_UNMAP_SG(DEV, SGLIST, NENTS, DIRECTION);

AGAIN, MAKE SURE DMA ACTIVITY HAS ALREADY FINISHED.

.. NOTE::

	THE 'NENTS' ARGUMENT TO THE DMA_UNMAP_SG CALL MUST BE
	THE _SAME_ ONE YOU PASSED INTO THE DMA_MAP_SG CALL,
	IT SHOULD _NOT_ BE THE 'COUNT' VALUE _RETURNED_ FROM THE
	DMA_MAP_SG CALL.

EVERY DMA_MAP_{SINGLE,SG}() CALL SHOULD HAVE ITS DMA_UNMAP_{SINGLE,SG}()
COUNTERPART, BECAUSE THE DMA ADDRESS SPACE IS A SHARED RESOURCE AND
YOU COULD RENDER THE MACHINE UNUSABLE BY CONSUMING ALL DMA ADDRESSES.

IF YOU NEED TO USE THE SAME STREAMING DMA REGION MULTIPLE TIMES AND TOUCH
THE DATA IN BETWEEN THE DMA TRANSFERS, THE BUFFER NEEDS TO BE SYNCED
PROPERLY IN ORDER FOR THE CPU AND DEVICE TO SEE THE MOST UP-TO-DATE AND
CORRECT COPY OF THE DMA BUFFER.

SO, FIRSTLY, JUST MAP IT WITH DMA_MAP_{SINGLE,SG}(), AND AFTER EACH DMA
TRANSFER CALL EITHER::

	DMA_SYNC_SINGLE_FOR_CPU(DEV, DMA_HANDLE, SIZE, DIRECTION);

OR::

	DMA_SYNC_SG_FOR_CPU(DEV, SGLIST, NENTS, DIRECTION);

AS APPROPRIATE.

THEN, IF YOU WISH TO LET THE DEVICE GET AT THE DMA AREA AGAIN,
FINISH ACCESSING THE DATA WITH THE CPU, AND THEN BEFORE ACTUALLY
GIVING THE BUFFER TO THE HARDWARE CALL EITHER::

	DMA_SYNC_SINGLE_FOR_DEVICE(DEV, DMA_HANDLE, SIZE, DIRECTION);

OR::

	DMA_SYNC_SG_FOR_DEVICE(DEV, SGLIST, NENTS, DIRECTION);

AS APPROPRIATE.

.. NOTE::

	      THE 'NENTS' ARGUMENT TO DMA_SYNC_SG_FOR_CPU() AND
	      DMA_SYNC_SG_FOR_DEVICE() MUST BE THE SAME PASSED TO
	      DMA_MAP_SG(). IT IS _NOT_ THE COUNT RETURNED BY
	      DMA_MAP_SG().

AFTER THE LAST DMA TRANSFER CALL ONE OF THE DMA UNMAP ROUTINES
DMA_UNMAP_{SINGLE,SG}(). IF YOU DON'T TOUCH THE DATA FROM THE FIRST
DMA_MAP_*() CALL TILL DMA_UNMAP_*(), THEN YOU DON'T HAVE TO CALL THE
DMA_SYNC_*() ROUTINES AT ALL.

HERE IS PSEUDO CODE WHICH SHOWS A SITUATION IN WHICH YOU WOULD NEED
TO USE THE DMA_SYNC_*() INTERFACES::

	MY_CARD_SETUP_RECEIVE_BUFFER(STRUCT MY_CARD *CP, CHAR *BUFFER, INT LEN)
	{
		DMA_ADDR_T MAPPING;

		MAPPING = DMA_MAP_SINGLE(CP->DEV, BUFFER, LEN, DMA_FROM_DEVICE);
		IF (DMA_MAPPING_ERROR(CP->DEV, MAPPING)) {
			/*
			 * REDUCE CURRENT DMA MAPPING USAGE,
			 * DELAY AND TRY AGAIN LATER OR
			 * RESET DRIVER.
			 */
			GOTO MAP_ERROR_HANDLING;
		}

		CP->RX_BUF = BUFFER;
		CP->RX_LEN = LEN;
		CP->RX_DMA = MAPPING;

		GIVE_RX_BUF_TO_CARD(CP);
	}

	...

	MY_CARD_INTERRUPT_HANDLER(INT IRQ, VOID *DEVID, STRUCT PT_REGS *REGS)
	{
		STRUCT MY_CARD *CP = DEVID;

		...
		IF (READ_CARD_STATUS(CP) == RX_BUF_TRANSFERRED) {
			STRUCT MY_CARD_HEADER *HP;

			/* EXAMINE THE HEADER TO SEE IF WE WISH
			 * TO ACCEPT THE DATA.  BUT SYNCHRONIZE
			 * THE DMA TRANSFER WITH THE CPU FIRST
			 * SO THAT WE SEE UPDATED CONTENTS.
			 */
			DMA_SYNC_SINGLE_FOR_CPU(&CP->DEV, CP->RX_DMA,
						CP->RX_LEN,
						DMA_FROM_DEVICE);

			/* NOW IT IS SAFE TO EXAMINE THE BUFFER. */
			HP = (STRUCT MY_CARD_HEADER *) CP->RX_BUF;
			IF (HEADER_IS_OK(HP)) {
				DMA_UNMAP_SINGLE(&CP->DEV, CP->RX_DMA, CP->RX_LEN,
						 DMA_FROM_DEVICE);
				PASS_TO_UPPER_LAYERS(CP->RX_BUF);
				MAKE_AND_SETUP_NEW_RX_BUF(CP);
			} ELSE {
				/* CPU SHOULD NOT WRITE TO
				 * DMA_FROM_DEVICE-MAPPED AREA,
				 * SO DMA_SYNC_SINGLE_FOR_DEVICE() IS
				 * NOT NEEDED HERE. IT WOULD BE REQUIRED
				 * FOR DMA_BIDIRECTIONAL MAPPING IF
				 * THE MEMORY WAS MODIFIED.
				 */
				GIVE_RX_BUF_TO_CARD(CP);
			}
		}
	}

DRIVERS CONVERTED FULLY TO THIS INTERFACE SHOULD NOT USE VIRT_TO_BUS() ANY
LONGER, NOR SHOULD THEY USE BUS_TO_VIRT(). SOME DRIVERS HAVE TO BE CHANGED A
LITTLE BIT, BECAUSE THERE IS NO LONGER AN EQUIVALENT TO BUS_TO_VIRT() IN THE
DYNAMIC DMA MAPPING SCHEME - YOU HAVE TO ALWAYS STORE THE DMA ADDRESSES
RETURNED BY THE DMA_ALLOC_COHERENT(), DMA_POOL_ALLOC(), AND DMA_MAP_SINGLE()
CALLS (DMA_MAP_SG() STORES THEM IN THE SCATTERLIST ITSELF IF THE PLATFORM
SUPPORTS DYNAMIC DMA MAPPING IN HARDWARE) IN YOUR DRIVER STRUCTURES AND/OR
IN THE CARD REGISTERS.

ALL DRIVERS SHOULD BE USING THESE INTERFACES WITH NO EXCEPTIONS.  IT
IS PLANNED TO COMPLETELY REMOVE VIRT_TO_BUS() AND BUS_TO_VIRT() AS
THEY ARE ENTIRELY DEPRECATED.  SOME PORTS ALREADY DO NOT PROVIDE THESE
AS IT IS IMPOSSIBLE TO CORRECTLY SUPPORT THEM.

HANDLING ERRORS
===============

DMA ADDRESS SPACE IS LIMITED ON SOME ARCHITECTURES AND AN ALLOCATION
FAILURE CAN BE DETERMINED BY:

- CHECKING IF DMA_ALLOC_COHERENT() RETURNS NULL OR DMA_MAP_SG RETURNS 0

- CHECKING THE DMA_ADDR_T RETURNED FROM DMA_MAP_SINGLE() AND DMA_MAP_PAGE()
  BY USING DMA_MAPPING_ERROR()::

	DMA_ADDR_T DMA_HANDLE;

	DMA_HANDLE = DMA_MAP_SINGLE(DEV, ADDR, SIZE, DIRECTION);
	IF (DMA_MAPPING_ERROR(DEV, DMA_HANDLE)) {
		/*
		 * REDUCE CURRENT DMA MAPPING USAGE,
		 * DELAY AND TRY AGAIN LATER OR
		 * RESET DRIVER.
		 */
		GOTO MAP_ERROR_HANDLING;
	}

- UNMAP PAGES THAT ARE ALREADY MAPPED, WHEN MAPPING ERROR OCCURS IN THE MIDDLE
  OF A MULTIPLE PAGE MAPPING ATTEMPT. THESE EXAMPLE ARE APPLICABLE TO
  DMA_MAP_PAGE() AS WELL.

EXAMPLE 1::

	DMA_ADDR_T DMA_HANDLE1;
	DMA_ADDR_T DMA_HANDLE2;

	DMA_HANDLE1 = DMA_MAP_SINGLE(DEV, ADDR, SIZE, DIRECTION);
	IF (DMA_MAPPING_ERROR(DEV, DMA_HANDLE1)) {
		/*
		 * REDUCE CURRENT DMA MAPPING USAGE,
		 * DELAY AND TRY AGAIN LATER OR
		 * RESET DRIVER.
		 */
		GOTO MAP_ERROR_HANDLING1;
	}
	DMA_HANDLE2 = DMA_MAP_SINGLE(DEV, ADDR, SIZE, DIRECTION);
	IF (DMA_MAPPING_ERROR(DEV, DMA_HANDLE2)) {
		/*
		 * REDUCE CURRENT DMA MAPPING USAGE,
		 * DELAY AND TRY AGAIN LATER OR
		 * RESET DRIVER.
		 */
		GOTO MAP_ERROR_HANDLING2;
	}

	...

	MAP_ERROR_HANDLING2:
		DMA_UNMAP_SINGLE(DMA_HANDLE1);
	MAP_ERROR_HANDLING1:

EXAMPLE 2::

	/*
	 * IF BUFFERS ARE ALLOCATED IN A LOOP, UNMAP ALL MAPPED BUFFERS WHEN
	 * MAPPING ERROR IS DETECTED IN THE MIDDLE
	 */

	DMA_ADDR_T DMA_ADDR;
	DMA_ADDR_T ARRAY[DMA_BUFFERS];
	INT SAVE_INDEX = 0;

	FOR (I = 0; I < DMA_BUFFERS; I++) {

		...

		DMA_ADDR = DMA_MAP_SINGLE(DEV, ADDR, SIZE, DIRECTION);
		IF (DMA_MAPPING_ERROR(DEV, DMA_ADDR)) {
			/*
			 * REDUCE CURRENT DMA MAPPING USAGE,
			 * DELAY AND TRY AGAIN LATER OR
			 * RESET DRIVER.
			 */
			GOTO MAP_ERROR_HANDLING;
		}
		ARRAY[I].DMA_ADDR = DMA_ADDR;
		SAVE_INDEX++;
	}

	...

	MAP_ERROR_HANDLING:

	FOR (I = 0; I < SAVE_INDEX; I++) {

		...

		DMA_UNMAP_SINGLE(ARRAY[I].DMA_ADDR);
	}

NETWORKING DRIVERS MUST CALL DEV_KFREE_SKB() TO FREE THE SOCKET BUFFER
AND RETURN NETDEV_TX_OK IF THE DMA MAPPING FAILS ON THE TRANSMIT HOOK
(NDO_START_XMIT). THIS MEANS THAT THE SOCKET BUFFER IS JUST DROPPED IN
THE FAILURE CASE.

SCSI DRIVERS MUST RETURN SCSI_MLQUEUE_HOST_BUSY IF THE DMA MAPPING
FAILS IN THE QUEUECOMMAND HOOK. THIS MEANS THAT THE SCSI SUBSYSTEM
PASSES THE COMMAND TO THE DRIVER AGAIN LATER.

OPTIMIZING UNMAP STATE SPACE CONSUMPTION
========================================

ON MANY PLATFORMS, DMA_UNMAP_{SINGLE,PAGE}() IS SIMPLY A NOP.
THEREFORE, KEEPING TRACK OF THE MAPPING ADDRESS AND LENGTH IS A WASTE
OF SPACE.  INSTEAD OF FILLING YOUR DRIVERS UP WITH IFDEFS AND THE LIKE
TO "WORK AROUND" THIS (WHICH WOULD DEFEAT THE WHOLE PURPOSE OF A
PORTABLE API) THE FOLLOWING FACILITIES ARE PROVIDED.

ACTUALLY, INSTEAD OF DESCRIBING THE MACROS ONE BY ONE, WE'LL
TRANSFORM SOME EXAMPLE CODE.

1) USE DEFINE_DMA_UNMAP_{ADDR,LEN} IN STATE SAVING STRUCTURES.
   EXAMPLE, BEFORE::

	STRUCT RING_STATE {
		STRUCT SK_BUFF *SKB;
		DMA_ADDR_T MAPPING;
		__U32 LEN;
	};

   AFTER::

	STRUCT RING_STATE {
		STRUCT SK_BUFF *SKB;
		DEFINE_DMA_UNMAP_ADDR(MAPPING);
		DEFINE_DMA_UNMAP_LEN(LEN);
	};

2) USE DMA_UNMAP_{ADDR,LEN}_SET() TO SET THESE VALUES.
   EXAMPLE, BEFORE::

	RINGP->MAPPING = FOO;
	RINGP->LEN = BAR;

   AFTER::

	DMA_UNMAP_ADDR_SET(RINGP, MAPPING, FOO);
	DMA_UNMAP_LEN_SET(RINGP, LEN, BAR);

3) USE DMA_UNMAP_{ADDR,LEN}() TO ACCESS THESE VALUES.
   EXAMPLE, BEFORE::

	DMA_UNMAP_SINGLE(DEV, RINGP->MAPPING, RINGP->LEN,
			 DMA_FROM_DEVICE);

   AFTER::

	DMA_UNMAP_SINGLE(DEV,
			 DMA_UNMAP_ADDR(RINGP, MAPPING),
			 DMA_UNMAP_LEN(RINGP, LEN),
			 DMA_FROM_DEVICE);

IT REALLY SHOULD BE SELF-EXPLANATORY.  WE TREAT THE ADDR AND LEN
SEPARATELY, BECAUSE IT IS POSSIBLE FOR AN IMPLEMENTATION TO ONLY
NEED THE ADDRESS IN ORDER TO PERFORM THE UNMAP OPERATION.

PLATFORM ISSUES
===============

IF YOU ARE JUST WRITING DRIVERS FOR LINUX AND DO NOT MAINTAIN
AN ARCHITECTURE PORT FOR THE KERNEL, YOU CAN SAFELY SKIP DOWN
TO "CLOSING".

1) STRUCT SCATTERLIST REQUIREMENTS.

   YOU NEED TO ENABLE CONFIG_NEED_SG_DMA_LENGTH IF THE ARCHITECTURE
   SUPPORTS IOMMUS (INCLUDING SOFTWARE IOMMU).

2) ARCH_DMA_MINALIGN

   ARCHITECTURES MUST ENSURE THAT KMALLOC'ED BUFFER IS
   DMA-SAFE. DRIVERS AND SUBSYSTEMS DEPEND ON IT. IF AN ARCHITECTURE
   ISN'T FULLY DMA-COHERENT (I.E. HARDWARE DOESN'T ENSURE THAT DATA IN
   THE CPU CACHE IS IDENTICAL TO DATA IN MAIN MEMORY),
   ARCH_DMA_MINALIGN MUST BE SET SO THAT THE MEMORY ALLOCATOR
   MAKES SURE THAT KMALLOC'ED BUFFER DOESN'T SHARE A CACHE LINE WITH
   THE OTHERS. SEE ARCH/ARM/INCLUDE/ASM/CACHE.H AS AN EXAMPLE.

   NOTE THAT ARCH_DMA_MINALIGN IS ABOUT DMA MEMORY ALIGNMENT
   CONSTRAINTS. YOU DON'T NEED TO WORRY ABOUT THE ARCHITECTURE DATA
   ALIGNMENT CONSTRAINTS (E.G. THE ALIGNMENT CONSTRAINTS ABOUT 64-BIT
   OBJECTS).

CLOSING
=======

THIS DOCUMENT, AND THE API ITSELF, WOULD NOT BE IN ITS CURRENT
FORM WITHOUT THE FEEDBACK AND SUGGESTIONS FROM NUMEROUS INDIVIDUALS.
WE WOULD LIKE TO SPECIFICALLY MENTION, IN NO PARTICULAR ORDER, THE
FOLLOWING PEOPLE::

	RUSSELL KING <RMK@ARM.LINUX.ORG.UK>
	LEO DAGUM <DAGUM@BARREL.ENGR.SGI.COM>
	RALF BAECHLE <RALF@OSS.SGI.COM>
	GRANT GRUNDLER <GRUNDLER@CUP.HP.COM>
	JAY ESTABROOK <JAY.ESTABROOK@COMPAQ.COM>
	THOMAS SAILER <SAILER@IFE.EE.ETHZ.CH>
	ANDREA ARCANGELI <ANDREA@SUSE.DE>
	JENS AXBOE <JENS.AXBOE@ORACLE.COM>
	DAVID MOSBERGER-TANG <DAVIDM@HPL.HP.COM>

=========================
DYNAMIC DMA MAPPING GUIDE
=========================

:AUTHOR: DAVID S. MILLER <DAVEM@REDHAT.COM>
:AUTHOR: RICHARD HENDERSON <RTH@CYGNUS.COM>
:AUTHOR: JAKUB JELINEK <JAKUB@REDHAT.COM>

THIS IS A GUIDE TO DEVICE DRIVER WRITERS ON HOW TO USE THE DMA API
WITH EXAMPLE PSEUDO-CODE.  FOR A CONCISE DESCRIPTION OF THE API, SEE
DMA-API.TXT.

CPU AND DMA ADDRESSES
=====================

THERE ARE SEVERAL KINDS OF ADDRESSES INVOLVED IN THE DMA API, AND IT'S
IMPORTANT TO UNDERSTAND THE DIFFERENCES.

THE KERNEL NORMALLY USES VIRTUAL ADDRESSES.  ANY ADDRESS RETURNED BY
KMALLOC(), VMALLOC(), AND SIMILAR INTERFACES IS A VIRTUAL ADDRESS AND CAN
BE STORED IN A ``VOID *``.

THE VIRTUAL MEMORY SYSTEM (TLB, PAGE TABLES, ETC.) TRANSLATES VIRTUAL
ADDRESSES TO CPU PHYSICAL ADDRESSES, WHICH ARE STORED AS "PHYS_ADDR_T" OR
"RESOURCE_SIZE_T".  THE KERNEL MANAGES DEVICE RESOURCES LIKE REGISTERS AS
PHYSICAL ADDRESSES.  THESE ARE THE ADDRESSES IN /PROC/IOMEM.  THE PHYSICAL
ADDRESS IS NOT DIRECTLY USEFUL TO A DRIVER; IT MUST USE IOREMAP() TO MAP
THE SPACE AND PRODUCE A VIRTUAL ADDRESS.

I/O DEVICES USE A THIRD KIND OF ADDRESS: A "BUS ADDRESS".  IF A DEVICE HAS
REGISTERS AT AN MMIO ADDRESS, OR IF IT PERFORMS DMA TO READ OR WRITE SYSTEM
MEMORY, THE ADDRESSES USED BY THE DEVICE ARE BUS ADDRESSES.  IN SOME
SYSTEMS, BUS ADDRESSES ARE IDENTICAL TO CPU PHYSICAL ADDRESSES, BUT IN
GENERAL THEY ARE NOT.  IOMMUS AND HOST BRIDGES CAN PRODUCE ARBITRARY
MAPPINGS BETWEEN PHYSICAL AND BUS ADDRESSES.

FROM A DEVICE'S POINT OF VIEW, DMA USES THE BUS ADDRESS SPACE, BUT IT MAY
BE RESTRICTED TO A SUBSET OF THAT SPACE.  FOR EXAMPLE, EVEN IF A SYSTEM
SUPPORTS 64-BIT ADDRESSES FOR MAIN MEMORY AND PCI BARS, IT MAY USE AN IOMMU
SO DEVICES ONLY NEED TO USE 32-BIT DMA ADDRESSES.

HERE'S A PICTURE AND SOME EXAMPLES::

               CPU                  CPU                  BUS
             VIRTUAL              PHYSICAL             ADDRESS
             ADDRESS              ADDRESS               SPACE
              SPACE                SPACE

            +-------+             +------+             +------+
            |       |             |MMIO  |   OFFSET    |      |
            |       |  VIRTUAL    |SPACE |   APPLIED   |      |
          C +-------+ --------> B +------+ ----------> +------+ A
            |       |  MAPPING    |      |   BY HOST   |      |
  +-----+   |       |             |      |   BRIDGE    |      |   +--------+
  |     |   |       |             +------+             |      |   |        |
  | CPU |   |       |             | RAM  |             |      |   | DEVICE |
  |     |   |       |             |      |             |      |   |        |
  +-----+   +-------+             +------+             +------+   +--------+
            |       |  VIRTUAL    |BUFFER|   MAPPING   |      |
          X +-------+ --------> Y +------+ <---------- +------+ Z
            |       |  MAPPING    | RAM  |   BY IOMMU
            |       |             |      |
            |       |             |      |
            +-------+             +------+

DURING THE ENUMERATION PROCESS, THE KERNEL LEARNS ABOUT I/O DEVICES AND
THEIR MMIO SPACE AND THE HOST BRIDGES THAT CONNECT THEM TO THE SYSTEM.  FOR
EXAMPLE, IF A PCI DEVICE HAS A BAR, THE KERNEL READS THE BUS ADDRESS (A)
FROM THE BAR AND CONVERTS IT TO A CPU PHYSICAL ADDRESS (B).  THE ADDRESS B
IS STORED IN A STRUCT RESOURCE AND USUALLY EXPOSED VIA /PROC/IOMEM.  WHEN A
DRIVER CLAIMS A DEVICE, IT TYPICALLY USES IOREMAP() TO MAP PHYSICAL ADDRESS
B AT A VIRTUAL ADDRESS (C).  IT CAN THEN USE, E.G., IOREAD32(C), TO ACCESS
THE DEVICE REGISTERS AT BUS ADDRESS A.

IF THE DEVICE SUPPORTS DMA, THE DRIVER SETS UP A BUFFER USING KMALLOC() OR
A SIMILAR INTERFACE, WHICH RETURNS A VIRTUAL ADDRESS (X).  THE VIRTUAL
MEMORY SYSTEM MAPS X TO A PHYSICAL ADDRESS (Y) IN SYSTEM RAM.  THE DRIVER
CAN USE VIRTUAL ADDRESS X TO ACCESS THE BUFFER, BUT THE DEVICE ITSELF
CANNOT BECAUSE DMA DOESN'T GO THROUGH THE CPU VIRTUAL MEMORY SYSTEM.

IN SOME SIMPLE SYSTEMS, THE DEVICE CAN DO DMA DIRECTLY TO PHYSICAL ADDRESS
Y.  BUT IN MANY OTHERS, THERE IS IOMMU HARDWARE THAT TRANSLATES DMA
ADDRESSES TO PHYSICAL ADDRESSES, E.G., IT TRANSLATES Z TO Y.  THIS IS PART
OF THE REASON FOR THE DMA API: THE DRIVER CAN GIVE A VIRTUAL ADDRESS X TO
AN INTERFACE LIKE DMA_MAP_SINGLE(), WHICH SETS UP ANY REQUIRED IOMMU
MAPPING AND RETURNS THE DMA ADDRESS Z.  THE DRIVER THEN TELLS THE DEVICE TO
DO DMA TO Z, AND THE IOMMU MAPS IT TO THE BUFFER AT ADDRESS Y IN SYSTEM
RAM.

SO THAT LINUX CAN USE THE DYNAMIC DMA MAPPING, IT NEEDS SOME HELP FROM THE
DRIVERS, NAMELY IT HAS TO TAKE INTO ACCOUNT THAT DMA ADDRESSES SHOULD BE
MAPPED ONLY FOR THE TIME THEY ARE ACTUALLY USED AND UNMAPPED AFTER THE DMA
TRANSFER.

THE FOLLOWING API WILL WORK OF COURSE EVEN ON PLATFORMS WHERE NO SUCH
HARDWARE EXISTS.

NOTE THAT THE DMA API WORKS WITH ANY BUS INDEPENDENT OF THE UNDERLYING
MICROPROCESSOR ARCHITECTURE. YOU SHOULD USE THE DMA API RATHER THAN THE
BUS-SPECIFIC DMA API, I.E., USE THE DMA_MAP_*() INTERFACES RATHER THAN THE
PCI_MAP_*() INTERFACES.

FIRST OF ALL, YOU SHOULD MAKE SURE::

	#INCLUDE <LINUX/DMA-MAPPING.H>

IS IN YOUR DRIVER, WHICH PROVIDES THE DEFINITION OF DMA_ADDR_T.  THIS TYPE
CAN HOLD ANY VALID DMA ADDRESS FOR THE PLATFORM AND SHOULD BE USED
EVERYWHERE YOU HOLD A DMA ADDRESS RETURNED FROM THE DMA MAPPING FUNCTIONS.

WHAT MEMORY IS DMA'ABLE?
========================

THE FIRST PIECE OF INFORMATION YOU MUST KNOW IS WHAT KERNEL MEMORY CAN
BE USED WITH THE DMA MAPPING FACILITIES.  THERE HAS BEEN AN UNWRITTEN
SET OF RULES REGARDING THIS, AND THIS TEXT IS AN ATTEMPT TO FINALLY
WRITE THEM DOWN.

IF YOU ACQUIRED YOUR MEMORY VIA THE PAGE ALLOCATOR
(I.E. __GET_FREE_PAGE*()) OR THE GENERIC MEMORY ALLOCATORS
(I.E. KMALLOC() OR KMEM_CACHE_ALLOC()) THEN YOU MAY DMA TO/FROM
THAT MEMORY USING THE ADDRESSES RETURNED FROM THOSE ROUTINES.

THIS MEANS SPECIFICALLY THAT YOU MAY _NOT_ USE THE MEMORY/ADDRESSES
RETURNED FROM VMALLOC() FOR DMA.  IT IS POSSIBLE TO DMA TO THE
_UNDERLYING_ MEMORY MAPPED INTO A VMALLOC() AREA, BUT THIS REQUIRES
WALKING PAGE TABLES TO GET THE PHYSICAL ADDRESSES, AND THEN
TRANSLATING EACH OF THOSE PAGES BACK TO A KERNEL ADDRESS USING
SOMETHING LIKE __VA().  [ EDIT: UPDATE THIS WHEN WE INTEGRATE
GERD KNORR'S GENERIC CODE WHICH DOES THIS. ]

THIS RULE ALSO MEANS THAT YOU MAY USE NEITHER KERNEL IMAGE ADDRESSES
(ITEMS IN DATA/TEXT/BSS SEGMENTS), NOR MODULE IMAGE ADDRESSES, NOR
STACK ADDRESSES FOR DMA.  THESE COULD ALL BE MAPPED SOMEWHERE ENTIRELY
DIFFERENT THAN THE REST OF PHYSICAL MEMORY.  EVEN IF THOSE CLASSES OF
MEMORY COULD PHYSICALLY WORK WITH DMA, YOU'D NEED TO ENSURE THE I/O
BUFFERS WERE CACHELINE-ALIGNED.  WITHOUT THAT, YOU'D SEE CACHELINE
SHARING PROBLEMS (DATA CORRUPTION) ON CPUS WITH DMA-INCOHERENT CACHES.
(THE CPU COULD WRITE TO ONE WORD, DMA WOULD WRITE TO A DIFFERENT ONE
IN THE SAME CACHE LINE, AND ONE OF THEM COULD BE OVERWRITTEN.)

ALSO, THIS MEANS THAT YOU CANNOT TAKE THE RETURN OF A KMAP()
CALL AND DMA TO/FROM THAT.  THIS IS SIMILAR TO VMALLOC().

WHAT ABOUT BLOCK I/O AND NETWORKING BUFFERS?  THE BLOCK I/O AND
NETWORKING SUBSYSTEMS MAKE SURE THAT THE BUFFERS THEY USE ARE VALID
FOR YOU TO DMA FROM/TO.

DMA ADDRESSING CAPABILITIES
===========================

BY DEFAULT, THE KERNEL ASSUMES THAT YOUR DEVICE CAN ADDRESS 32-BITS OF DMA
ADDRESSING.  FOR A 64-BIT CAPABLE DEVICE, THIS NEEDS TO BE INCREASED, AND FOR
A DEVICE WITH LIMITATIONS, IT NEEDS TO BE DECREASED.

SPECIAL NOTE ABOUT PCI: PCI-X SPECIFICATION REQUIRES PCI-X DEVICES TO SUPPORT
64-BIT ADDRESSING (DAC) FOR ALL TRANSACTIONS.  AND AT LEAST ONE PLATFORM (SGI
SN2) REQUIRES 64-BIT CONSISTENT ALLOCATIONS TO OPERATE CORRECTLY WHEN THE IO
BUS IS IN PCI-X MODE.

FOR CORRECT OPERATION, YOU MUST SET THE DMA MASK TO INFORM THE KERNEL ABOUT
YOUR DEVICES DMA ADDRESSING CAPABILITIES.

THIS IS PERFORMED VIA A CALL TO DMA_SET_MASK_AND_COHERENT()::

	INT DMA_SET_MASK_AND_COHERENT(STRUCT DEVICE *DEV, U64 MASK);

WHICH WILL SET THE MASK FOR BOTH STREAMING AND COHERENT APIS TOGETHER.  IF YOU
HAVE SOME SPECIAL REQUIREMENTS, THEN THE FOLLOWING TWO SEPARATE CALLS CAN BE
USED INSTEAD:

	THE SETUP FOR STREAMING MAPPINGS IS PERFORMED VIA A CALL TO
	DMA_SET_MASK()::

		INT DMA_SET_MASK(STRUCT DEVICE *DEV, U64 MASK);

	THE SETUP FOR CONSISTENT ALLOCATIONS IS PERFORMED VIA A CALL
	TO DMA_SET_COHERENT_MASK()::

		INT DMA_SET_COHERENT_MASK(STRUCT DEVICE *DEV, U64 MASK);

HERE, DEV IS A POINTER TO THE DEVICE STRUCT OF YOUR DEVICE, AND MASK IS A BIT
MASK DESCRIBING WHICH BITS OF AN ADDRESS YOUR DEVICE SUPPORTS.  OFTEN THE
DEVICE STRUCT OF YOUR DEVICE IS EMBEDDED IN THE BUS-SPECIFIC DEVICE STRUCT OF
YOUR DEVICE.  FOR EXAMPLE, &PDEV->DEV IS A POINTER TO THE DEVICE STRUCT OF A
PCI DEVICE (PDEV IS A POINTER TO THE PCI DEVICE STRUCT OF YOUR DEVICE).

THESE CALLS USUALLY RETURN ZERO TO INDICATED YOUR DEVICE CAN PERFORM DMA
PROPERLY ON THE MACHINE GIVEN THE ADDRESS MASK YOU PROVIDED, BUT THEY MIGHT
RETURN AN ERROR IF THE MASK IS TOO SMALL TO BE SUPPORTABLE ON THE GIVEN
SYSTEM.  IF IT RETURNS NON-ZERO, YOUR DEVICE CANNOT PERFORM DMA PROPERLY ON
THIS PLATFORM, AND ATTEMPTING TO DO SO WILL RESULT IN UNDEFINED BEHAVIOR.
YOU MUST NOT USE DMA ON THIS DEVICE UNLESS THE DMA_SET_MASK FAMILY OF
FUNCTIONS HAS RETURNED SUCCESS.

THIS MEANS THAT IN THE FAILURE CASE, YOU HAVE TWO OPTIONS:

1) USE SOME NON-DMA MODE FOR DATA TRANSFER, IF POSSIBLE.
2) IGNORE THIS DEVICE AND DO NOT INITIALIZE IT.

IT IS RECOMMENDED THAT YOUR DRIVER PRINT A KERNEL KERN_WARNING MESSAGE WHEN
SETTING THE DMA MASK FAILS.  IN THIS MANNER, IF A USER OF YOUR DRIVER REPORTS
THAT PERFORMANCE IS BAD OR THAT THE DEVICE IS NOT EVEN DETECTED, YOU CAN ASK
THEM FOR THE KERNEL MESSAGES TO FIND OUT EXACTLY WHY.

THE STANDARD 64-BIT ADDRESSING DEVICE WOULD DO SOMETHING LIKE THIS::

	IF (DMA_SET_MASK_AND_COHERENT(DEV, DMA_BIT_MASK(64))) {
		DEV_WARN(DEV, "MYDEV: NO SUITABLE DMA AVAILABLE\N");
		GOTO IGNORE_THIS_DEVICE;
	}

IF THE DEVICE ONLY SUPPORTS 32-BIT ADDRESSING FOR DESCRIPTORS IN THE
COHERENT ALLOCATIONS, BUT SUPPORTS FULL 64-BITS FOR STREAMING MAPPINGS
IT WOULD LOOK LIKE THIS::

	IF (DMA_SET_MASK(DEV, DMA_BIT_MASK(64))) {
		DEV_WARN(DEV, "MYDEV: NO SUITABLE DMA AVAILABLE\N");
		GOTO IGNORE_THIS_DEVICE;
	}

THE COHERENT MASK WILL ALWAYS BE ABLE TO SET THE SAME OR A SMALLER MASK AS
THE STREAMING MASK. HOWEVER FOR THE RARE CASE THAT A DEVICE DRIVER ONLY
USES CONSISTENT ALLOCATIONS, ONE WOULD HAVE TO CHECK THE RETURN VALUE FROM
DMA_SET_COHERENT_MASK().

FINALLY, IF YOUR DEVICE CAN ONLY DRIVE THE LOW 24-BITS OF
ADDRESS YOU MIGHT DO SOMETHING LIKE::

	IF (DMA_SET_MASK(DEV, DMA_BIT_MASK(24))) {
		DEV_WARN(DEV, "MYDEV: 24-BIT DMA ADDRESSING NOT AVAILABLE\N");
		GOTO IGNORE_THIS_DEVICE;
	}

WHEN DMA_SET_MASK() OR DMA_SET_MASK_AND_COHERENT() IS SUCCESSFUL, AND
RETURNS ZERO, THE KERNEL SAVES AWAY THIS MASK YOU HAVE PROVIDED.  THE
KERNEL WILL USE THIS INFORMATION LATER WHEN YOU MAKE DMA MAPPINGS.

THERE IS A CASE WHICH WE ARE AWARE OF AT THIS TIME, WHICH IS WORTH
MENTIONING IN THIS DOCUMENTATION.  IF YOUR DEVICE SUPPORTS MULTIPLE
FUNCTIONS (FOR EXAMPLE A SOUND CARD PROVIDES PLAYBACK AND RECORD
FUNCTIONS) AND THE VARIOUS DIFFERENT FUNCTIONS HAVE _DIFFERENT_
DMA ADDRESSING LIMITATIONS, YOU MAY WISH TO PROBE EACH MASK AND
ONLY PROVIDE THE FUNCTIONALITY WHICH THE MACHINE CAN HANDLE.  IT
IS IMPORTANT THAT THE LAST CALL TO DMA_SET_MASK() BE FOR THE
MOST SPECIFIC MASK.

HERE IS PSEUDO-CODE SHOWING HOW THIS MIGHT BE DONE::

	#DEFINE PLAYBACK_ADDRESS_BITS	DMA_BIT_MASK(32)
	#DEFINE RECORD_ADDRESS_BITS	DMA_BIT_MASK(24)

	STRUCT MY_SOUND_CARD *CARD;
	STRUCT DEVICE *DEV;

	...
	IF (!DMA_SET_MASK(DEV, PLAYBACK_ADDRESS_BITS)) {
		CARD->PLAYBACK_ENABLED = 1;
	} ELSE {
		CARD->PLAYBACK_ENABLED = 0;
		DEV_WARN(DEV, "%S: PLAYBACK DISABLED DUE TO DMA LIMITATIONS\N",
		       CARD->NAME);
	}
	IF (!DMA_SET_MASK(DEV, RECORD_ADDRESS_BITS)) {
		CARD->RECORD_ENABLED = 1;
	} ELSE {
		CARD->RECORD_ENABLED = 0;
		DEV_WARN(DEV, "%S: RECORD DISABLED DUE TO DMA LIMITATIONS\N",
		       CARD->NAME);
	}

A SOUND CARD WAS USED AS AN EXAMPLE HERE BECAUSE THIS GENRE OF PCI
DEVICES SEEMS TO BE LITTERED WITH ISA CHIPS GIVEN A PCI FRONT END,
AND THUS RETAINING THE 16MB DMA ADDRESSING LIMITATIONS OF ISA.

TYPES OF DMA MAPPINGS
=====================

THERE ARE TWO TYPES OF DMA MAPPINGS:

- CONSISTENT DMA MAPPINGS WHICH ARE USUALLY MAPPED AT DRIVER
  INITIALIZATION, UNMAPPED AT THE END AND FOR WHICH THE HARDWARE SHOULD
  GUARANTEE THAT THE DEVICE AND THE CPU CAN ACCESS THE DATA
  IN PARALLEL AND WILL SEE UPDATES MADE BY EACH OTHER WITHOUT ANY
  EXPLICIT SOFTWARE FLUSHING.

  THINK OF "CONSISTENT" AS "SYNCHRONOUS" OR "COHERENT".

  THE CURRENT DEFAULT IS TO RETURN CONSISTENT MEMORY IN THE LOW 32
  BITS OF THE DMA SPACE.  HOWEVER, FOR FUTURE COMPATIBILITY YOU SHOULD
  SET THE CONSISTENT MASK EVEN IF THIS DEFAULT IS FINE FOR YOUR
  DRIVER.

  GOOD EXAMPLES OF WHAT TO USE CONSISTENT MAPPINGS FOR ARE:

	- NETWORK CARD DMA RING DESCRIPTORS.
	- SCSI ADAPTER MAILBOX COMMAND DATA STRUCTURES.
	- DEVICE FIRMWARE MICROCODE EXECUTED OUT OF
	  MAIN MEMORY.

  THE INVARIANT THESE EXAMPLES ALL REQUIRE IS THAT ANY CPU STORE
  TO MEMORY IS IMMEDIATELY VISIBLE TO THE DEVICE, AND VICE
  VERSA.  CONSISTENT MAPPINGS GUARANTEE THIS.

  .. IMPORTANT::

	     CONSISTENT DMA MEMORY DOES NOT PRECLUDE THE USAGE OF
	     PROPER MEMORY BARRIERS.  THE CPU MAY REORDER STORES TO
	     CONSISTENT MEMORY JUST AS IT MAY NORMAL MEMORY.  EXAMPLE:
	     IF IT IS IMPORTANT FOR THE DEVICE TO SEE THE FIRST WORD
	     OF A DESCRIPTOR UPDATED BEFORE THE SECOND, YOU MUST DO
	     SOMETHING LIKE::

		DESC->WORD0 = ADDRESS;
		WMB();
		DESC->WORD1 = DESC_VALID;

             IN ORDER TO GET CORRECT BEHAVIOR ON ALL PLATFORMS.

	     ALSO, ON SOME PLATFORMS YOUR DRIVER MAY NEED TO FLUSH CPU WRITE
	     BUFFERS IN MUCH THE SAME WAY AS IT NEEDS TO FLUSH WRITE BUFFERS
	     FOUND IN PCI BRIDGES (SUCH AS BY READING A REGISTER'S VALUE
	     AFTER WRITING IT).

- STREAMING DMA MAPPINGS WHICH ARE USUALLY MAPPED FOR ONE DMA
  TRANSFER, UNMAPPED RIGHT AFTER IT (UNLESS YOU USE DMA_SYNC_* BELOW)
  AND FOR WHICH HARDWARE CAN OPTIMIZE FOR SEQUENTIAL ACCESSES.

  THINK OF "STREAMING" AS "ASYNCHRONOUS" OR "OUTSIDE THE COHERENCY
  DOMAIN".

  GOOD EXAMPLES OF WHAT TO USE STREAMING MAPPINGS FOR ARE:

	- NETWORKING BUFFERS TRANSMITTED/RECEIVED BY A DEVICE.
	- FILESYSTEM BUFFERS WRITTEN/READ BY A SCSI DEVICE.

  THE INTERFACES FOR USING THIS TYPE OF MAPPING WERE DESIGNED IN
  SUCH A WAY THAT AN IMPLEMENTATION CAN MAKE WHATEVER PERFORMANCE
  OPTIMIZATIONS THE HARDWARE ALLOWS.  TO THIS END, WHEN USING
  SUCH MAPPINGS YOU MUST BE EXPLICIT ABOUT WHAT YOU WANT TO HAPPEN.

NEITHER TYPE OF DMA MAPPING HAS ALIGNMENT RESTRICTIONS THAT COME FROM
THE UNDERLYING BUS, ALTHOUGH SOME DEVICES MAY HAVE SUCH RESTRICTIONS.
ALSO, SYSTEMS WITH CACHES THAT AREN'T DMA-COHERENT WILL WORK BETTER
WHEN THE UNDERLYING BUFFERS DON'T SHARE CACHE LINES WITH OTHER DATA.


USING CONSISTENT DMA MAPPINGS
=============================

TO ALLOCATE AND MAP LARGE (PAGE_SIZE OR SO) CONSISTENT DMA REGIONS,
YOU SHOULD DO::

	DMA_ADDR_T DMA_HANDLE;

	CPU_ADDR = DMA_ALLOC_COHERENT(DEV, SIZE, &DMA_HANDLE, GFP);

WHERE DEVICE IS A ``STRUCT DEVICE *``. THIS MAY BE CALLED IN INTERRUPT
CONTEXT WITH THE GFP_ATOMIC FLAG.

SIZE IS THE LENGTH OF THE REGION YOU WANT TO ALLOCATE, IN BYTES.

THIS ROUTINE WILL ALLOCATE RAM FOR THAT REGION, SO IT ACTS SIMILARLY TO
__GET_FREE_PAGES() (BUT TAKES SIZE INSTEAD OF A PAGE ORDER).  IF YOUR
DRIVER NEEDS REGIONS SIZED SMALLER THAN A PAGE, YOU MAY PREFER USING
THE DMA_POOL INTERFACE, DESCRIBED BELOW.

THE CONSISTENT DMA MAPPING INTERFACES, WILL BY DEFAULT RETURN A DMA ADDRESS
WHICH IS 32-BIT ADDRESSABLE.  EVEN IF THE DEVICE INDICATES (VIA THE DMA MASK)
THAT IT MAY ADDRESS THE UPPER 32-BITS, CONSISTENT ALLOCATION WILL ONLY
RETURN > 32-BIT ADDRESSES FOR DMA IF THE CONSISTENT DMA MASK HAS BEEN
EXPLICITLY CHANGED VIA DMA_SET_COHERENT_MASK().  THIS IS TRUE OF THE
DMA_POOL INTERFACE AS WELL.

DMA_ALLOC_COHERENT() RETURNS TWO VALUES: THE VIRTUAL ADDRESS WHICH YOU
CAN USE TO ACCESS IT FROM THE CPU AND DMA_HANDLE WHICH YOU PASS TO THE
CARD.

THE CPU VIRTUAL ADDRESS AND THE DMA ADDRESS ARE BOTH
GUARANTEED TO BE ALIGNED TO THE SMALLEST PAGE_SIZE ORDER WHICH
IS GREATER THAN OR EQUAL TO THE REQUESTED SIZE.  THIS INVARIANT
EXISTS (FOR EXAMPLE) TO GUARANTEE THAT IF YOU ALLOCATE A CHUNK
WHICH IS SMALLER THAN OR EQUAL TO 64 KILOBYTES, THE EXTENT OF THE
BUFFER YOU RECEIVE WILL NOT CROSS A 64K BOUNDARY.

TO UNMAP AND FREE SUCH A DMA REGION, YOU CALL::

	DMA_FREE_COHERENT(DEV, SIZE, CPU_ADDR, DMA_HANDLE);

WHERE DEV, SIZE ARE THE SAME AS IN THE ABOVE CALL AND CPU_ADDR AND
DMA_HANDLE ARE THE VALUES DMA_ALLOC_COHERENT() RETURNED TO YOU.
THIS FUNCTION MAY NOT BE CALLED IN INTERRUPT CONTEXT.

IF YOUR DRIVER NEEDS LOTS OF SMALLER MEMORY REGIONS, YOU CAN WRITE
CUSTOM CODE TO SUBDIVIDE PAGES RETURNED BY DMA_ALLOC_COHERENT(),
OR YOU CAN USE THE DMA_POOL API TO DO THAT.  A DMA_POOL IS LIKE
A KMEM_CACHE, BUT IT USES DMA_ALLOC_COHERENT(), NOT __GET_FREE_PAGES().
ALSO, IT UNDERSTANDS COMMON HARDWARE CONSTRAINTS FOR ALIGNMENT,
LIKE QUEUE HEADS NEEDING TO BE ALIGNED ON N BYTE BOUNDARIES.

CREATE A DMA_POOL LIKE THIS::

	STRUCT DMA_POOL *POOL;

	POOL = DMA_POOL_CREATE(NAME, DEV, SIZE, ALIGN, BOUNDARY);

THE "NAME" IS FOR DIAGNOSTICS (LIKE A KMEM_CACHE NAME); DEV AND SIZE
ARE AS ABOVE.  THE DEVICE'S HARDWARE ALIGNMENT REQUIREMENT FOR THIS
TYPE OF DATA IS "ALIGN" (WHICH IS EXPRESSED IN BYTES, AND MUST BE A
POWER OF TWO).  IF YOUR DEVICE HAS NO BOUNDARY CROSSING RESTRICTIONS,
PASS 0 FOR BOUNDARY; PASSING 4096 SAYS MEMORY ALLOCATED FROM THIS POOL
MUST NOT CROSS 4KBYTE BOUNDARIES (BUT AT THAT TIME IT MAY BE BETTER TO
USE DMA_ALLOC_COHERENT() DIRECTLY INSTEAD).

ALLOCATE MEMORY FROM A DMA POOL LIKE THIS::

	CPU_ADDR = DMA_POOL_ALLOC(POOL, FLAGS, &DMA_HANDLE);

FLAGS ARE GFP_KERNEL IF BLOCKING IS PERMITTED (NOT IN_INTERRUPT NOR
HOLDING SMP LOCKS), GFP_ATOMIC OTHERWISE.  LIKE DMA_ALLOC_COHERENT(),
THIS RETURNS TWO VALUES, CPU_ADDR AND DMA_HANDLE.

FREE MEMORY THAT WAS ALLOCATED FROM A DMA_POOL LIKE THIS::

	DMA_POOL_FREE(POOL, CPU_ADDR, DMA_HANDLE);

WHERE POOL IS WHAT YOU PASSED TO DMA_POOL_ALLOC(), AND CPU_ADDR AND
DMA_HANDLE ARE THE VALUES DMA_POOL_ALLOC() RETURNED. THIS FUNCTION
MAY BE CALLED IN INTERRUPT CONTEXT.

DESTROY A DMA_POOL BY CALLING::

	DMA_POOL_DESTROY(POOL);

MAKE SURE YOU'VE CALLED DMA_POOL_FREE() FOR ALL MEMORY ALLOCATED
FROM A POOL BEFORE YOU DESTROY THE POOL. THIS FUNCTION MAY NOT
BE CALLED IN INTERRUPT CONTEXT.

DMA DIRECTION
=============

THE INTERFACES DESCRIBED IN SUBSEQUENT PORTIONS OF THIS DOCUMENT
TAKE A DMA DIRECTION ARGUMENT, WHICH IS AN INTEGER AND TAKES ON
ONE OF THE FOLLOWING VALUES::

 DMA_BIDIRECTIONAL
 DMA_TO_DEVICE
 DMA_FROM_DEVICE
 DMA_NONE

YOU SHOULD PROVIDE THE EXACT DMA DIRECTION IF YOU KNOW IT.

DMA_TO_DEVICE MEANS "FROM MAIN MEMORY TO THE DEVICE"
DMA_FROM_DEVICE MEANS "FROM THE DEVICE TO MAIN MEMORY"
IT IS THE DIRECTION IN WHICH THE DATA MOVES DURING THE DMA
TRANSFER.

YOU ARE _STRONGLY_ ENCOURAGED TO SPECIFY THIS AS PRECISELY
AS YOU POSSIBLY CAN.

IF YOU ABSOLUTELY CANNOT KNOW THE DIRECTION OF THE DMA TRANSFER,
SPECIFY DMA_BIDIRECTIONAL.  IT MEANS THAT THE DMA CAN GO IN
EITHER DIRECTION.  THE PLATFORM GUARANTEES THAT YOU MAY LEGALLY
SPECIFY THIS, AND THAT IT WILL WORK, BUT THIS MAY BE AT THE
COST OF PERFORMANCE FOR EXAMPLE.

THE VALUE DMA_NONE IS TO BE USED FOR DEBUGGING.  ONE CAN
HOLD THIS IN A DATA STRUCTURE BEFORE YOU COME TO KNOW THE
PRECISE DIRECTION, AND THIS WILL HELP CATCH CASES WHERE YOUR
DIRECTION TRACKING LOGIC HAS FAILED TO SET THINGS UP PROPERLY.

ANOTHER ADVANTAGE OF SPECIFYING THIS VALUE PRECISELY (OUTSIDE OF
POTENTIAL PLATFORM-SPECIFIC OPTIMIZATIONS OF SUCH) IS FOR DEBUGGING.
SOME PLATFORMS ACTUALLY HAVE A WRITE PERMISSION BOOLEAN WHICH DMA
MAPPINGS CAN BE MARKED WITH, MUCH LIKE PAGE PROTECTIONS IN THE USER
PROGRAM ADDRESS SPACE.  SUCH PLATFORMS CAN AND DO REPORT ERRORS IN THE
KERNEL LOGS WHEN THE DMA CONTROLLER HARDWARE DETECTS VIOLATION OF THE
PERMISSION SETTING.

ONLY STREAMING MAPPINGS SPECIFY A DIRECTION, CONSISTENT MAPPINGS
IMPLICITLY HAVE A DIRECTION ATTRIBUTE SETTING OF
DMA_BIDIRECTIONAL.

THE SCSI SUBSYSTEM TELLS YOU THE DIRECTION TO USE IN THE
'SC_DATA_DIRECTION' MEMBER OF THE SCSI COMMAND YOUR DRIVER IS
WORKING ON.

FOR NETWORKING DRIVERS, IT'S A RATHER SIMPLE AFFAIR.  FOR TRANSMIT
PACKETS, MAP/UNMAP THEM WITH THE DMA_TO_DEVICE DIRECTION
SPECIFIER.  FOR RECEIVE PACKETS, JUST THE OPPOSITE, MAP/UNMAP THEM
WITH THE DMA_FROM_DEVICE DIRECTION SPECIFIER.

USING STREAMING DMA MAPPINGS
============================

THE STREAMING DMA MAPPING ROUTINES CAN BE CALLED FROM INTERRUPT
CONTEXT.  THERE ARE TWO VERSIONS OF EACH MAP/UNMAP, ONE WHICH WILL
MAP/UNMAP A SINGLE MEMORY REGION, AND ONE WHICH WILL MAP/UNMAP A
SCATTERLIST.

TO MAP A SINGLE REGION, YOU DO::

	STRUCT DEVICE *DEV = &MY_DEV->DEV;
	DMA_ADDR_T DMA_HANDLE;
	VOID *ADDR = BUFFER->PTR;
	SIZE_T SIZE = BUFFER->LEN;

	DMA_HANDLE = DMA_MAP_SINGLE(DEV, ADDR, SIZE, DIRECTION);
	IF (DMA_MAPPING_ERROR(DEV, DMA_HANDLE)) {
		/*
		 * REDUCE CURRENT DMA MAPPING USAGE,
		 * DELAY AND TRY AGAIN LATER OR
		 * RESET DRIVER.
		 */
		GOTO MAP_ERROR_HANDLING;
	}

AND TO UNMAP IT::

	DMA_UNMAP_SINGLE(DEV, DMA_HANDLE, SIZE, DIRECTION);

YOU SHOULD CALL DMA_MAPPING_ERROR() AS DMA_MAP_SINGLE() COULD FAIL AND RETURN
ERROR.  DOING SO WILL ENSURE THAT THE MAPPING CODE WILL WORK CORRECTLY ON ALL
DMA IMPLEMENTATIONS WITHOUT ANY DEPENDENCY ON THE SPECIFICS OF THE UNDERLYING
IMPLEMENTATION. USING THE RETURNED ADDRESS WITHOUT CHECKING FOR ERRORS COULD
RESULT IN FAILURES RANGING FROM PANICS TO SILENT DATA CORRUPTION.  THE SAME
APPLIES TO DMA_MAP_PAGE() AS WELL.

YOU SHOULD CALL DMA_UNMAP_SINGLE() WHEN THE DMA ACTIVITY IS FINISHED, E.G.,
FROM THE INTERRUPT WHICH TOLD YOU THAT THE DMA TRANSFER IS DONE.

USING CPU POINTERS LIKE THIS FOR SINGLE MAPPINGS HAS A DISADVANTAGE:
YOU CANNOT REFERENCE HIGHMEM MEMORY IN THIS WAY.  THUS, THERE IS A
MAP/UNMAP INTERFACE PAIR AKIN TO DMA_{MAP,UNMAP}_SINGLE().  THESE
INTERFACES DEAL WITH PAGE/OFFSET PAIRS INSTEAD OF CPU POINTERS.
SPECIFICALLY::

	STRUCT DEVICE *DEV = &MY_DEV->DEV;
	DMA_ADDR_T DMA_HANDLE;
	STRUCT PAGE *PAGE = BUFFER->PAGE;
	UNSIGNED LONG OFFSET = BUFFER->OFFSET;
	SIZE_T SIZE = BUFFER->LEN;

	DMA_HANDLE = DMA_MAP_PAGE(DEV, PAGE, OFFSET, SIZE, DIRECTION);
	IF (DMA_MAPPING_ERROR(DEV, DMA_HANDLE)) {
		/*
		 * REDUCE CURRENT DMA MAPPING USAGE,
		 * DELAY AND TRY AGAIN LATER OR
		 * RESET DRIVER.
		 */
		GOTO MAP_ERROR_HANDLING;
	}

	...

	DMA_UNMAP_PAGE(DEV, DMA_HANDLE, SIZE, DIRECTION);

HERE, "OFFSET" MEANS BYTE OFFSET WITHIN THE GIVEN PAGE.

YOU SHOULD CALL DMA_MAPPING_ERROR() AS DMA_MAP_PAGE() COULD FAIL AND RETURN
ERROR AS OUTLINED UNDER THE DMA_MAP_SINGLE() DISCUSSION.

YOU SHOULD CALL DMA_UNMAP_PAGE() WHEN THE DMA ACTIVITY IS FINISHED, E.G.,
FROM THE INTERRUPT WHICH TOLD YOU THAT THE DMA TRANSFER IS DONE.

WITH SCATTERLISTS, YOU MAP A REGION GATHERED FROM SEVERAL REGIONS BY::

	INT I, COUNT = DMA_MAP_SG(DEV, SGLIST, NENTS, DIRECTION);
	STRUCT SCATTERLIST *SG;

	FOR_EACH_SG(SGLIST, SG, COUNT, I) {
		HW_ADDRESS[I] = SG_DMA_ADDRESS(SG);
		HW_LEN[I] = SG_DMA_LEN(SG);
	}

WHERE NENTS IS THE NUMBER OF ENTRIES IN THE SGLIST.

THE IMPLEMENTATION IS FREE TO MERGE SEVERAL CONSECUTIVE SGLIST ENTRIES
INTO ONE (E.G. IF DMA MAPPING IS DONE WITH PAGE_SIZE GRANULARITY, ANY
CONSECUTIVE SGLIST ENTRIES CAN BE MERGED INTO ONE PROVIDED THE FIRST ONE
ENDS AND THE SECOND ONE STARTS ON A PAGE BOUNDARY - IN FACT THIS IS A HUGE
ADVANTAGE FOR CARDS WHICH EITHER CANNOT DO SCATTER-GATHER OR HAVE VERY
LIMITED NUMBER OF SCATTER-GATHER ENTRIES) AND RETURNS THE ACTUAL NUMBER
OF SG ENTRIES IT MAPPED THEM TO. ON FAILURE 0 IS RETURNED.

THEN YOU SHOULD LOOP COUNT TIMES (NOTE: THIS CAN BE LESS THAN NENTS TIMES)
AND USE SG_DMA_ADDRESS() AND SG_DMA_LEN() MACROS WHERE YOU PREVIOUSLY
ACCESSED SG->ADDRESS AND SG->LENGTH AS SHOWN ABOVE.

TO UNMAP A SCATTERLIST, JUST CALL::

	DMA_UNMAP_SG(DEV, SGLIST, NENTS, DIRECTION);

AGAIN, MAKE SURE DMA ACTIVITY HAS ALREADY FINISHED.

.. NOTE::

	THE 'NENTS' ARGUMENT TO THE DMA_UNMAP_SG CALL MUST BE
	THE _SAME_ ONE YOU PASSED INTO THE DMA_MAP_SG CALL,
	IT SHOULD _NOT_ BE THE 'COUNT' VALUE _RETURNED_ FROM THE
	DMA_MAP_SG CALL.

EVERY DMA_MAP_{SINGLE,SG}() CALL SHOULD HAVE ITS DMA_UNMAP_{SINGLE,SG}()
COUNTERPART, BECAUSE THE DMA ADDRESS SPACE IS A SHARED RESOURCE AND
YOU COULD RENDER THE MACHINE UNUSABLE BY CONSUMING ALL DMA ADDRESSES.

IF YOU NEED TO USE THE SAME STREAMING DMA REGION MULTIPLE TIMES AND TOUCH
THE DATA IN BETWEEN THE DMA TRANSFERS, THE BUFFER NEEDS TO BE SYNCED
PROPERLY IN ORDER FOR THE CPU AND DEVICE TO SEE THE MOST UP-TO-DATE AND
CORRECT COPY OF THE DMA BUFFER.

SO, FIRSTLY, JUST MAP IT WITH DMA_MAP_{SINGLE,SG}(), AND AFTER EACH DMA
TRANSFER CALL EITHER::

	DMA_SYNC_SINGLE_FOR_CPU(DEV, DMA_HANDLE, SIZE, DIRECTION);

OR::

	DMA_SYNC_SG_FOR_CPU(DEV, SGLIST, NENTS, DIRECTION);

AS APPROPRIATE.

THEN, IF YOU WISH TO LET THE DEVICE GET AT THE DMA AREA AGAIN,
FINISH ACCESSING THE DATA WITH THE CPU, AND THEN BEFORE ACTUALLY
GIVING THE BUFFER TO THE HARDWARE CALL EITHER::

	DMA_SYNC_SINGLE_FOR_DEVICE(DEV, DMA_HANDLE, SIZE, DIRECTION);

OR::

	DMA_SYNC_SG_FOR_DEVICE(DEV, SGLIST, NENTS, DIRECTION);

AS APPROPRIATE.

.. NOTE::

	      THE 'NENTS' ARGUMENT TO DMA_SYNC_SG_FOR_CPU() AND
	      DMA_SYNC_SG_FOR_DEVICE() MUST BE THE SAME PASSED TO
	      DMA_MAP_SG(). IT IS _NOT_ THE COUNT RETURNED BY
	      DMA_MAP_SG().

AFTER THE LAST DMA TRANSFER CALL ONE OF THE DMA UNMAP ROUTINES
DMA_UNMAP_{SINGLE,SG}(). IF YOU DON'T TOUCH THE DATA FROM THE FIRST
DMA_MAP_*() CALL TILL DMA_UNMAP_*(), THEN YOU DON'T HAVE TO CALL THE
DMA_SYNC_*() ROUTINES AT ALL.

HERE IS PSEUDO CODE WHICH SHOWS A SITUATION IN WHICH YOU WOULD NEED
TO USE THE DMA_SYNC_*() INTERFACES::

	MY_CARD_SETUP_RECEIVE_BUFFER(STRUCT MY_CARD *CP, CHAR *BUFFER, INT LEN)
	{
		DMA_ADDR_T MAPPING;

		MAPPING = DMA_MAP_SINGLE(CP->DEV, BUFFER, LEN, DMA_FROM_DEVICE);
		IF (DMA_MAPPING_ERROR(CP->DEV, MAPPING)) {
			/*
			 * REDUCE CURRENT DMA MAPPING USAGE,
			 * DELAY AND TRY AGAIN LATER OR
			 * RESET DRIVER.
			 */
			GOTO MAP_ERROR_HANDLING;
		}

		CP->RX_BUF = BUFFER;
		CP->RX_LEN = LEN;
		CP->RX_DMA = MAPPING;

		GIVE_RX_BUF_TO_CARD(CP);
	}

	...

	MY_CARD_INTERRUPT_HANDLER(INT IRQ, VOID *DEVID, STRUCT PT_REGS *REGS)
	{
		STRUCT MY_CARD *CP = DEVID;

		...
		IF (READ_CARD_STATUS(CP) == RX_BUF_TRANSFERRED) {
			STRUCT MY_CARD_HEADER *HP;

			/* EXAMINE THE HEADER TO SEE IF WE WISH
			 * TO ACCEPT THE DATA.  BUT SYNCHRONIZE
			 * THE DMA TRANSFER WITH THE CPU FIRST
			 * SO THAT WE SEE UPDATED CONTENTS.
			 */
			DMA_SYNC_SINGLE_FOR_CPU(&CP->DEV, CP->RX_DMA,
						CP->RX_LEN,
						DMA_FROM_DEVICE);

			/* NOW IT IS SAFE TO EXAMINE THE BUFFER. */
			HP = (STRUCT MY_CARD_HEADER *) CP->RX_BUF;
			IF (HEADER_IS_OK(HP)) {
				DMA_UNMAP_SINGLE(&CP->DEV, CP->RX_DMA, CP->RX_LEN,
						 DMA_FROM_DEVICE);
				PASS_TO_UPPER_LAYERS(CP->RX_BUF);
				MAKE_AND_SETUP_NEW_RX_BUF(CP);
			} ELSE {
				/* CPU SHOULD NOT WRITE TO
				 * DMA_FROM_DEVICE-MAPPED AREA,
				 * SO DMA_SYNC_SINGLE_FOR_DEVICE() IS
				 * NOT NEEDED HERE. IT WOULD BE REQUIRED
				 * FOR DMA_BIDIRECTIONAL MAPPING IF
				 * THE MEMORY WAS MODIFIED.
				 */
				GIVE_RX_BUF_TO_CARD(CP);
			}
		}
	}

DRIVERS CONVERTED FULLY TO THIS INTERFACE SHOULD NOT USE VIRT_TO_BUS() ANY
LONGER, NOR SHOULD THEY USE BUS_TO_VIRT(). SOME DRIVERS HAVE TO BE CHANGED A
LITTLE BIT, BECAUSE THERE IS NO LONGER AN EQUIVALENT TO BUS_TO_VIRT() IN THE
DYNAMIC DMA MAPPING SCHEME - YOU HAVE TO ALWAYS STORE THE DMA ADDRESSES
RETURNED BY THE DMA_ALLOC_COHERENT(), DMA_POOL_ALLOC(), AND DMA_MAP_SINGLE()
CALLS (DMA_MAP_SG() STORES THEM IN THE SCATTERLIST ITSELF IF THE PLATFORM
SUPPORTS DYNAMIC DMA MAPPING IN HARDWARE) IN YOUR DRIVER STRUCTURES AND/OR
IN THE CARD REGISTERS.

ALL DRIVERS SHOULD BE USING THESE INTERFACES WITH NO EXCEPTIONS.  IT
IS PLANNED TO COMPLETELY REMOVE VIRT_TO_BUS() AND BUS_TO_VIRT() AS
THEY ARE ENTIRELY DEPRECATED.  SOME PORTS ALREADY DO NOT PROVIDE THESE
AS IT IS IMPOSSIBLE TO CORRECTLY SUPPORT THEM.

HANDLING ERRORS
===============

DMA ADDRESS SPACE IS LIMITED ON SOME ARCHITECTURES AND AN ALLOCATION
FAILURE CAN BE DETERMINED BY:

- CHECKING IF DMA_ALLOC_COHERENT() RETURNS NULL OR DMA_MAP_SG RETURNS 0

- CHECKING THE DMA_ADDR_T RETURNED FROM DMA_MAP_SINGLE() AND DMA_MAP_PAGE()
  BY USING DMA_MAPPING_ERROR()::

	DMA_ADDR_T DMA_HANDLE;

	DMA_HANDLE = DMA_MAP_SINGLE(DEV, ADDR, SIZE, DIRECTION);
	IF (DMA_MAPPING_ERROR(DEV, DMA_HANDLE)) {
		/*
		 * REDUCE CURRENT DMA MAPPING USAGE,
		 * DELAY AND TRY AGAIN LATER OR
		 * RESET DRIVER.
		 */
		GOTO MAP_ERROR_HANDLING;
	}

- UNMAP PAGES THAT ARE ALREADY MAPPED, WHEN MAPPING ERROR OCCURS IN THE MIDDLE
  OF A MULTIPLE PAGE MAPPING ATTEMPT. THESE EXAMPLE ARE APPLICABLE TO
  DMA_MAP_PAGE() AS WELL.

EXAMPLE 1::

	DMA_ADDR_T DMA_HANDLE1;
	DMA_ADDR_T DMA_HANDLE2;

	DMA_HANDLE1 = DMA_MAP_SINGLE(DEV, ADDR, SIZE, DIRECTION);
	IF (DMA_MAPPING_ERROR(DEV, DMA_HANDLE1)) {
		/*
		 * REDUCE CURRENT DMA MAPPING USAGE,
		 * DELAY AND TRY AGAIN LATER OR
		 * RESET DRIVER.
		 */
		GOTO MAP_ERROR_HANDLING1;
	}
	DMA_HANDLE2 = DMA_MAP_SINGLE(DEV, ADDR, SIZE, DIRECTION);
	IF (DMA_MAPPING_ERROR(DEV, DMA_HANDLE2)) {
		/*
		 * REDUCE CURRENT DMA MAPPING USAGE,
		 * DELAY AND TRY AGAIN LATER OR
		 * RESET DRIVER.
		 */
		GOTO MAP_ERROR_HANDLING2;
	}

	...

	MAP_ERROR_HANDLING2:
		DMA_UNMAP_SINGLE(DMA_HANDLE1);
	MAP_ERROR_HANDLING1:

EXAMPLE 2::

	/*
	 * IF BUFFERS ARE ALLOCATED IN A LOOP, UNMAP ALL MAPPED BUFFERS WHEN
	 * MAPPING ERROR IS DETECTED IN THE MIDDLE
	 */

	DMA_ADDR_T DMA_ADDR;
	DMA_ADDR_T ARRAY[DMA_BUFFERS];
	INT SAVE_INDEX = 0;

	FOR (I = 0; I < DMA_BUFFERS; I++) {

		...

		DMA_ADDR = DMA_MAP_SINGLE(DEV, ADDR, SIZE, DIRECTION);
		IF (DMA_MAPPING_ERROR(DEV, DMA_ADDR)) {
			/*
			 * REDUCE CURRENT DMA MAPPING USAGE,
			 * DELAY AND TRY AGAIN LATER OR
			 * RESET DRIVER.
			 */
			GOTO MAP_ERROR_HANDLING;
		}
		ARRAY[I].DMA_ADDR = DMA_ADDR;
		SAVE_INDEX++;
	}

	...

	MAP_ERROR_HANDLING:

	FOR (I = 0; I < SAVE_INDEX; I++) {

		...

		DMA_UNMAP_SINGLE(ARRAY[I].DMA_ADDR);
	}

NETWORKING DRIVERS MUST CALL DEV_KFREE_SKB() TO FREE THE SOCKET BUFFER
AND RETURN NETDEV_TX_OK IF THE DMA MAPPING FAILS ON THE TRANSMIT HOOK
(NDO_START_XMIT). THIS MEANS THAT THE SOCKET BUFFER IS JUST DROPPED IN
THE FAILURE CASE.

SCSI DRIVERS MUST RETURN SCSI_MLQUEUE_HOST_BUSY IF THE DMA MAPPING
FAILS IN THE QUEUECOMMAND HOOK. THIS MEANS THAT THE SCSI SUBSYSTEM
PASSES THE COMMAND TO THE DRIVER AGAIN LATER.

OPTIMIZING UNMAP STATE SPACE CONSUMPTION
========================================

ON MANY PLATFORMS, DMA_UNMAP_{SINGLE,PAGE}() IS SIMPLY A NOP.
THEREFORE, KEEPING TRACK OF THE MAPPING ADDRESS AND LENGTH IS A WASTE
OF SPACE.  INSTEAD OF FILLING YOUR DRIVERS UP WITH IFDEFS AND THE LIKE
TO "WORK AROUND" THIS (WHICH WOULD DEFEAT THE WHOLE PURPOSE OF A
PORTABLE API) THE FOLLOWING FACILITIES ARE PROVIDED.

ACTUALLY, INSTEAD OF DESCRIBING THE MACROS ONE BY ONE, WE'LL
TRANSFORM SOME EXAMPLE CODE.

1) USE DEFINE_DMA_UNMAP_{ADDR,LEN} IN STATE SAVING STRUCTURES.
   EXAMPLE, BEFORE::

	STRUCT RING_STATE {
		STRUCT SK_BUFF *SKB;
		DMA_ADDR_T MAPPING;
		__U32 LEN;
	};

   AFTER::

	STRUCT RING_STATE {
		STRUCT SK_BUFF *SKB;
		DEFINE_DMA_UNMAP_ADDR(MAPPING);
		DEFINE_DMA_UNMAP_LEN(LEN);
	};

2) USE DMA_UNMAP_{ADDR,LEN}_SET() TO SET THESE VALUES.
   EXAMPLE, BEFORE::

	RINGP->MAPPING = FOO;
	RINGP->LEN = BAR;

   AFTER::

	DMA_UNMAP_ADDR_SET(RINGP, MAPPING, FOO);
	DMA_UNMAP_LEN_SET(RINGP, LEN, BAR);

3) USE DMA_UNMAP_{ADDR,LEN}() TO ACCESS THESE VALUES.
   EXAMPLE, BEFORE::

	DMA_UNMAP_SINGLE(DEV, RINGP->MAPPING, RINGP->LEN,
			 DMA_FROM_DEVICE);

   AFTER::

	DMA_UNMAP_SINGLE(DEV,
			 DMA_UNMAP_ADDR(RINGP, MAPPING),
			 DMA_UNMAP_LEN(RINGP, LEN),
			 DMA_FROM_DEVICE);

IT REALLY SHOULD BE SELF-EXPLANATORY.  WE TREAT THE ADDR AND LEN
SEPARATELY, BECAUSE IT IS POSSIBLE FOR AN IMPLEMENTATION TO ONLY
NEED THE ADDRESS IN ORDER TO PERFORM THE UNMAP OPERATION.

PLATFORM ISSUES
===============

IF YOU ARE JUST WRITING DRIVERS FOR LINUX AND DO NOT MAINTAIN
AN ARCHITECTURE PORT FOR THE KERNEL, YOU CAN SAFELY SKIP DOWN
TO "CLOSING".

1) STRUCT SCATTERLIST REQUIREMENTS.

   YOU NEED TO ENABLE CONFIG_NEED_SG_DMA_LENGTH IF THE ARCHITECTURE
   SUPPORTS IOMMUS (INCLUDING SOFTWARE IOMMU).

2) ARCH_DMA_MINALIGN

   ARCHITECTURES MUST ENSURE THAT KMALLOC'ED BUFFER IS
   DMA-SAFE. DRIVERS AND SUBSYSTEMS DEPEND ON IT. IF AN ARCHITECTURE
   ISN'T FULLY DMA-COHERENT (I.E. HARDWARE DOESN'T ENSURE THAT DATA IN
   THE CPU CACHE IS IDENTICAL TO DATA IN MAIN MEMORY),
   ARCH_DMA_MINALIGN MUST BE SET SO THAT THE MEMORY ALLOCATOR
   MAKES SURE THAT KMALLOC'ED BUFFER DOESN'T SHARE A CACHE LINE WITH
   THE OTHERS. SEE ARCH/ARM/INCLUDE/ASM/CACHE.H AS AN EXAMPLE.

   NOTE THAT ARCH_DMA_MINALIGN IS ABOUT DMA MEMORY ALIGNMENT
   CONSTRAINTS. YOU DON'T NEED TO WORRY ABOUT THE ARCHITECTURE DATA
   ALIGNMENT CONSTRAINTS (E.G. THE ALIGNMENT CONSTRAINTS ABOUT 64-BIT
   OBJECTS).

CLOSING
=======

THIS DOCUMENT, AND THE API ITSELF, WOULD NOT BE IN ITS CURRENT
FORM WITHOUT THE FEEDBACK AND SUGGESTIONS FROM NUMEROUS INDIVIDUALS.
WE WOULD LIKE TO SPECIFICALLY MENTION, IN NO PARTICULAR ORDER, THE
FOLLOWING PEOPLE::

	RUSSELL KING <RMK@ARM.LINUX.ORG.UK>
	LEO DAGUM <DAGUM@BARREL.ENGR.SGI.COM>
	RALF BAECHLE <RALF@OSS.SGI.COM>
	GRANT GRUNDLER <GRUNDLER@CUP.HP.COM>
	JAY ESTABROOK <JAY.ESTABROOK@COMPAQ.COM>
	THOMAS SAILER <SAILER@IFE.EE.ETHZ.CH>
	ANDREA ARCANGELI <ANDREA@SUSE.DE>
	JENS AXBOE <JENS.AXBOE@ORACLE.COM>
	DAVID MOSBERGER-TANG <DAVIDM@HPL.HP.COM>


